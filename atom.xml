<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Star</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xingxin-99.github.io/"/>
  <updated>2023-09-12T03:02:54.216Z</updated>
  <id>https://xingxin-99.github.io/</id>
  
  <author>
    <name>Star</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenBMI</title>
    <link href="https://xingxin-99.github.io/2023/09/12/OpenBMI/"/>
    <id>https://xingxin-99.github.io/2023/09/12/OpenBMI/</id>
    <published>2023-09-12T02:58:46.000Z</published>
    <updated>2023-09-12T03:02:54.216Z</updated>
    
    <content type="html"><![CDATA[<p>subject：54<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1666330616741-6588779a-6090-4b25-a372-5cc57d63786f.jpeg" alt></p><ul><li>通过问卷调查获取测试者的心理和生理状况信息，与任务无关的参数：比如静息状态、伪迹、双臂肌电图被记录<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2>54名健康受试者(年龄24 ~ 35岁; 25名女性)参加实验。38名受试者是未接触过BCI实验的用户，其他人以前有过BCI实验的经验。所有参与者都没有神经、精神或任何其他可能影响实验结果的相关疾病的病史。<br>受试者舒适地坐在一张椅子上，扶手在21英寸LCD显示器(刷新频率: 60 Hz ;决议: 1 600 × 1 200)前方<strong>60 ( ± 5 )厘米</strong>处。大致的<strong>水平和垂直视角分别为37.7和28.1度</strong>。在实验过程中，受试者被要求放松肌肉，尽量减少眼睛和肌肉的运动。<br>我们设计了三个单独的BCI实验：一个二分类MI系统、一个36个符号的ERP拼写器和一个四个目标频率的SSVEP系统。所有实验都遵循[ 2、39、40]中发现的<strong>常规BCI研究的共同原则</strong>。所有BCI实验都是基于<strong>OpenBMI [ 41 , 42]和心理物理学[ 43 ]工具箱</strong>开发的。<br>在实验之前，受试者<strong>阅读提供实验时间表、注意事项和任务解释的说明。在他们充分了解实验后，提供问卷I，记录他们的个人信息(例如,年龄,性别)，并检查他们的身体和精神状况。</strong>问卷I在实验(具体见表1)之前包含了一个可以外部影响受试者BCI表现的条件清单，并记录了他们的心理和生理状态。<strong>在开始主要实验之前，我们记录了这5种噪声信号中的每一种10秒的EEG数据：( 1 )眼睛眨眼，( 2 )重复的水平眼动，( 3 )重复的垂直眼动，( 4 )紧咬牙齿，( 5 )双臂弯曲。</strong><br>每个实验任务分两个阶段进行，一个训练阶段和一个测试阶段。在训练阶段，EEG数据被记录在离线条件下，随后用于构造分类器。在测试阶段，基于该分类器采集并解码实时EEG数据。<br>我们的实验需要相对较长的记录时间，因此保持用户的状态和信号质量是很重要的。因此，我们允许实验任务之间有灵活的休息时间。<strong>在每个范式结束时检查阻抗，并指导受试者在没有特定任务的情况下凝视监视器的中心点一分钟，以便记录每次实验任务前后的静息态脑电数据。在每次试验后，受试者填写了参考[ 8 ]设计的问卷II</strong>，以检查他们目前的状况，并检查先前进行的实验(详见表2)。整个实验过程总结于表3。<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1666331897164-d686c674-4065-4bc5-9ded-cd2c499a7616.png" alt="image.png"><br>EEG信号以1000 Hz的采样率记录，并用62 Ag/AgCl电极采集。实验中使用的脑电放大器为Brain Amp (脑产品;德国慕尼黑)。通道为钠参比，接地电极为AFz。此外，从每个趾深屈肌记录一个EMG电极，以尺骨鹰嘴作为参考。EEG / EMG通道配置和索引号如图1所示。在整个实验过程中，EEG电极的阻抗保持在10 K以下。</li></ul><h2 id="MI想象范式"><a href="#MI想象范式" class="headerlink" title="MI想象范式"></a>MI想象范式</h2><p>MI范式是根据一个成熟的系统协议设计的[ 2 ]。每个试验的<strong>前3 s</strong>开始与黑色的固定十字架出现在监视器的中心，为MI任务准备对象。之后，当右箭头或左箭头作为视觉线索出现时，受试者用适当的手进行<strong>4秒</strong>的抓取的想象任务。每次任务结束后，屏幕保持空白<strong>6 s</strong>。实验分为训练和测试阶段；<strong>每个阶段有100次均衡的右手和左手图像任务</strong>。在在线测试阶段，根据EEG信号的实时分类器输出，注视十字出现在监视器的中心并向右或向左移动<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1666331666911-03b8c8e7-c1d2-4772-9cfb-0147d431d04d.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32637015/1666332072830-6789193e-b79f-4992-b5b2-6173f69b3526.png#clientId=uc1070ae2-e2ed-4&amp;from=paste&amp;height=55&amp;id=u25e54173&amp;originHeight=55&amp;originWidth=410&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13107&amp;status=done&amp;style=none&amp;taskId=u5f86d34c-f67b-4ecd-ba8c-06da7a402db&amp;title=&amp;width=410" alt="image.png"><br>离线EEG数据通过<strong>5阶巴特沃斯数字滤波器在8和30 Hz之间进行带通滤波</strong>。然后将连续的EEG数据从1000 ms到3500 ms的刺激开始时间进行分段。因此，EEG历元组成<strong>为250 (数据点) × 20 (电极) × 100 (试次)</strong>。频率范围和时间间隔根据以前的MI研究[ 2 , 16]选择。CSP被用来最大化二进制类的区分度[ 23 ]，并计算对数方差特征。然后计算LDA分类器来解码左或右手图像任务。来自CSP投影矩阵的顶部和底部两行的子集以及LDA参数被提供给在线数据分析。<br>在在线测试阶段，创建了一个滑动窗口(长度1.5 s ;步长, 0.5 s)，用于对实时EEG数据进行分类。具体来说，该窗口缓冲区中的数据使用训练阶段使用的频率范围进行过滤，并将CSP投影矩阵w应用于这些EEG数据。每隔0.5 s计算一次LDA输出，并转换为十字架水平x轴的坐标，以提供实时的视觉反馈。</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1666331474673-9e6a68eb-ddf6-4ec3-a9c2-367cc3b6591d.png" alt="image.png"><br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1666331485947-90c3b97b-0546-4920-9272-6506883bc0cb.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;subject：54&lt;br&gt;&lt;img src=&quot;https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1666330616741-6588779a-6090-4b25-a372-5cc57d63786f.jpeg&quot; alt&gt;&lt;/
      
    
    </summary>
    
      <category term="BCI" scheme="https://xingxin-99.github.io/categories/BCI/"/>
    
    
      <category term="BCI" scheme="https://xingxin-99.github.io/tags/BCI/"/>
    
  </entry>
  
  <entry>
    <title>EEG数据</title>
    <link href="https://xingxin-99.github.io/2023/09/12/EEG%E6%95%B0%E6%8D%AE/"/>
    <id>https://xingxin-99.github.io/2023/09/12/EEG数据/</id>
    <published>2023-09-12T02:25:43.000Z</published>
    <updated>2023-09-12T02:59:10.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694429239022-53b90b87-c92b-47ea-a752-6f171d26c92c.jpeg" alt><br>总共有九个类别，每个被试开始运动想象打上对应类别标签，结束打上结束标签。</p><h2 id="分析annotations为721的原因"><a href="#分析annotations为721的原因" class="headerlink" title="分析annotations为721的原因"></a>分析annotations为721的原因</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694417892542-75c8adbf-e296-4262-9e15-b32bf53fceb1.png" alt="image.png"><br>每个类别40个trail，因此类别标签共40*9=360个。另外每个trail结束会打一个结束标签，因此共有结束标签360个。另外试验刚开始会打一个标签，因此总共有721个标签。</p><table><thead><tr><th>标记</th><th>类别</th></tr></thead><tbody><tr><td>1</td><td>左手</td></tr><tr><td>2</td><td>右手</td></tr><tr><td>3</td><td>伸肘</td></tr><tr><td>4</td><td>屈肘</td></tr><tr><td>5</td><td>上翻腕</td></tr><tr><td>6</td><td>下翻腕</td></tr><tr><td>7</td><td>握拳</td></tr><tr><td>8</td><td>松拳</td></tr><tr><td>9</td><td>静息</td></tr><tr><td>10</td><td>结束标志</td></tr></tbody></table><h2 id="数据基本信息"><a href="#数据基本信息" class="headerlink" title="数据基本信息"></a>数据基本信息</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694421793175-c15e9a64-9076-43ba-bd29-2f8df09af407.png" alt="image.png"></p><h2 id="数据预处理（滤波-凹陷滤波-降采样）"><a href="#数据预处理（滤波-凹陷滤波-降采样）" class="headerlink" title="数据预处理（滤波+凹陷滤波+降采样）"></a>数据预处理（滤波+凹陷滤波+降采样）</h2><pre><code class="python">#带通滤波raw_filter = raw.copy()raw_filter.filter(l_freq=0.5,h_freq=100)  #参考BCIIV2Araw_filter.notch_filter(freqs=50)  #一般做一个50hz凹陷滤波，事件干扰工频干扰eeg_filter = raw_filter.get_data()#降采样new_sfreq = 250raw_resampled = raw_filter.copy().resample(sfreq=new_sfreq)eeg_resampled = raw_resampled.get_data()</code></pre><p><strong>滤波前</strong></p><p><a href="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694431417932-43c560fa-86ec-47fe-b37a-a87fec73f0af.png" target="_blank" rel="noopener">image.png</a></p><p><strong>滤波后</strong><br>!<img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694431544937-3864f623-684f-4a02-915d-11fd7a1c96fa.png" alt="image.png"></p><h2 id="event标签数据"><a href="#event标签数据" class="headerlink" title="event标签数据"></a>event标签数据</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694417714048-b238b025-0d42-4797-aeb5-910e5295cc1e.png" alt="image.png"></p><ol><li><p>根据上述分析，以每个类别标签为起点，读取其后4s的想象数据。</p><pre><code class="python"># 类别标签eventCode = [1,2,3,4,5,6,7,8,9]#截取每个类别对应的eventevents = [event for event in gdf_events if event[1] in eventCode]</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694420506106-aa3d38c9-b5b1-4a36-aee3-dbae8ca1fd2e.png" alt="image.png"></p></li><li><p>读取类别标签</p><pre><code class="python">y = np.array([i[1] for i in events])</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1694420570578-6ab66bdb-19a4-428e-aa17-4f30158d7e4c.png" alt="image.png"></p></li><li><p>截取每个类别标签后读取的4s数据</p><pre><code class="python">epochInterval = np.array(range(epochWindow[0] * fs, epochWindow[1] * fs)) + offset * fsx = np.stack([eeg[:, epochInterval + event[0]] for event in events], axis=2)# Multiply the data with 1e3x = x * 1e3 # 这里参考FBCNet对于BCIIV2a读取的数据的处理，将数据 * 1e3</code></pre></li></ol><p><strong>完整代码</strong></p><pre><code class="python">import mneimport numpy as npimport matplotlib.pyplot as pltpath =&#39;E:\\Data\\2023_MI\\YJ\\0804_YJ.vhdr&#39;raw = mne.io.read_raw_brainvision(path,eog=(&#39;FT9&#39;,&#39;FT10&#39;),preload=True)eeg = raw.get_data()#带通滤波raw_filter = raw.copy()raw_filter.filter(l_freq=0.5,h_freq=100)  #参考BCIIV2Araw_filter.notch_filter(freqs=50)  #一般做一个50hz凹陷滤波，事件干扰工频干扰eeg_filter = raw_filter.get_data()#降采样new_sfreq = 250raw_resampled = raw_filter.copy().resample(sfreq=new_sfreq)eeg_resampled = raw_resampled.get_data()# raw_resampled.plot(start=20,duration=1)# plt.show()#raw_event = mne.events_from_annotations(raw_resampled)gdf_events = raw_event[0][:, [0, 2]].tolist()eventCode = [1,2,3,4,5,6,7,8,9]offset = 6 # 从第6s开始读取真实运动想象数据epochWindow=[0, 4] #读取4s运动想象数据# Epoch the dataevents = [event for event in gdf_events if event[1] in eventCode]y = np.array([i[1] for i in events])epochInterval = np.array(range(epochWindow[0] * new_sfreq, epochWindow[1] * new_sfreq)) + offset * new_sfreqx = np.stack([eeg[:, epochInterval + event[0]] for event in events], axis=2)# Multiply the data with 1e6x = x * 1e3# change the labels from [1-9] to [0-8]y = y - 1data = {&#39;x&#39;: x, &#39;y&#39;: y, &#39;s&#39;: new_sfreq}</code></pre>]]></content>
    
    <summary type="html">
    
      数据集的相关处理
    
    </summary>
    
      <category term="BCI" scheme="https://xingxin-99.github.io/categories/BCI/"/>
    
    
      <category term="BCI" scheme="https://xingxin-99.github.io/tags/BCI/"/>
    
  </entry>
  
  <entry>
    <title>卷积核可视化</title>
    <link href="https://xingxin-99.github.io/2023/09/08/%E5%8D%B7%E7%A7%AF%E6%A0%B8%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://xingxin-99.github.io/2023/09/08/卷积核可视化/</id>
    <published>2023-09-08T10:24:34.000Z</published>
    <updated>2023-09-08T10:36:49.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卷积核可视化"><a href="#卷积核可视化" class="headerlink" title="卷积核可视化"></a>卷积核可视化</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>卷积核可视化可视的是卷积核的权重，其中颜色越深，代表权重越大。<br>亮的像素点代表小的权重，与之对应的图像中的像素产生的影响较小。暗的像素点代表大的权重，意味着对应的图像中的像素的影响较大。可看出这些特征映射反应了某些特殊的空间结构，因此CNN学习到了一些与空间结构有关的信息用于识别。<br>参考：<a href="https://blog.csdn.net/weixin_45918732/article/details/103270215" target="_blank" rel="noopener">[深度学习]神经网络中 权重矩阵/卷积核 以及 （y=wx+非线性变换）输出值/特征图的本质理解<em>少年初心的博客-CSDN博客</em>卷积核和权值矩阵</a></p><h2 id="可视化卷积核代码"><a href="#可视化卷积核代码" class="headerlink" title="可视化卷积核代码"></a>可视化卷积核代码</h2><pre><code class="python">import torchimport torchimport torch.nn as nnimport matplotlib.pyplot as pltimport numpy as np</code></pre><pre><code class="python">class eca_layer(nn.Module):    &quot;&quot;&quot;Constructs a ECA module.    Args:        channel: Number of channels of the input feature map        k_size: Adaptive selection of kernel size    &quot;&quot;&quot;    def __init__(self, channel, k_size=3):        super(eca_layer, self).__init__()        self.avg_pool = nn.AdaptiveAvgPool2d(1)        self.conv = nn.Conv1d(1, 1, kernel_size=k_size, padding=(k_size - 1) // 2, bias=False)        self.sigmoid = nn.Sigmoid()    def forward(self, x):        # x: input features with shape [b, c, h, w]        b, c, h, w = x.size()        # feature descriptor on the global spatial information        y = self.avg_pool(x)        y1 = y.squeeze(-1).transpose(-1, -2)        # Two different branches of ECA module        y2 = self.conv(y1)        y3 = y2.transpose(-1, -2).unsqueeze(-1)        # Multi-scale information fusion        y = self.sigmoid(y)        return x * y.expand_as(x)        # %% Support classes for ShallowFBCNet Implementationclass ActSquare(nn.Module):    def __init__(self):        super(ActSquare, self).__init__()        pass    def forward(self, x):        return torch.square(x)class ActLog(nn.Module):    def __init__(self, eps=1e-06):        super(ActLog, self).__init__()        self.eps = eps    def forward(self, x):        return torch.log(torch.clamp(x, min=self.eps))class Conv2dWithConstraint(nn.Conv2d):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(Conv2dWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(Conv2dWithConstraint, self).forward(x)class LinearWithConstraint(nn.Linear):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(LinearWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(LinearWithConstraint, self).forward(x)class MSASNet(nn.Module):    def __init__(self, nChan=22, nTime=1000, nClass=2, dropoutP=0.25, *args, **kwargs):        super(MSASNet, self).__init__()        self.timekernel = 25        self.poolkernel = 85        self.poolstride = 15        self.TC1 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),        )        self.TC2 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,        groups=20),        )        self.TC3 = nn.Sequential(        Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),        Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,        groups=20),        Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,        groups=20),        )        self.SP = nn.Sequential(        Conv2dWithConstraint(60, 120, (nChan, 1), max_norm=2, groups=60),        nn.BatchNorm2d(120),        ActSquare(),        nn.AvgPool2d((1, self.poolkernel), (1, self.poolstride)),        ActLog(),        )        self.ECA = eca_layer(120)        self.FC = nn.Sequential(        nn.Dropout(),        nn.Flatten(),        LinearWithConstraint(7440, nClass, max_norm=0.5),  # 3720-&gt;7440        nn.LogSoftmax(dim=1)        )        def forward(self, x):        x1 = self.TC1(x)        x2 = self.TC2(x)        x3 = self.TC3(x)        x = torch.cat((x1, x2, x3), dim=1)        x = self.SP(x)        x = self.ECA(x)        x = self.FC(x)        return x</code></pre><pre><code class="python"># 导入模型并加载最好的模型model =MSASNet(nChan=22, nTime=1000, nClass=4)model.load_state_dict(torch.load(&#39;C:/Users/star/Desktop/star/Coding/FBCNet/codes/netInitModels/MSASNet_0.pth&#39;))</code></pre><p>打印网络结构</p><pre><code class="python">MSASNet(  (TC1): Sequential(    (0): Conv2dWithConstraint(1, 20, kernel_size=(1, 25), stride=(1, 1), padding=(0, 12))  )  (TC2): Sequential(    (0): Conv2dWithConstraint(1, 20, kernel_size=(1, 25), stride=(1, 1), padding=(0, 12))    (1): Conv2dWithConstraint(20, 20, kernel_size=(1, 25), stride=(1, 1), padding=(0, 12), groups=20)  )  (TC3): Sequential(    (0): Conv2dWithConstraint(1, 20, kernel_size=(1, 25), stride=(1, 1), padding=(0, 12))    (1): Conv2dWithConstraint(20, 20, kernel_size=(1, 25), stride=(1, 1), padding=(0, 12), groups=20)    (2): Conv2dWithConstraint(20, 20, kernel_size=(1, 25), stride=(1, 1), padding=(0, 12), groups=20)  )  (SP): Sequential(    (0): Conv2dWithConstraint(60, 120, kernel_size=(22, 1), stride=(1, 1), groups=60)    (1): BatchNorm2d(120, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)    (2): ActSquare()    (3): AvgPool2d(kernel_size=(1, 85), stride=(1, 15), padding=0)    (4): ActLog()  )  (ECA): eca_layer(    (avg_pool): AdaptiveAvgPool2d(output_size=1)    (conv): Conv1d(1, 1, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)    (sigmoid): Sigmoid()  )  (FC): Sequential(    (0): Dropout(p=0.5, inplace=False)    (1): Flatten(start_dim=1, end_dim=-1)    (2): LinearWithConstraint(in_features=7440, out_features=4, bias=True)    (3): LogSoftmax(dim=1)  ))</code></pre><p>选择想要可视化的卷积核：</p><pre><code class="python">SPConv = dict(model.named_children())[&#39;SP&#39;][0] #获取对应的卷积层# out：Conv2dWithConstraint(60, 120, kernel_size=(22, 1), stride=(1, 1), groups=60)kernel_set = SPConv1.weight.detach() #获取该卷积层对应的卷积核权重# out：torch.Size([120, 1, 22, 1])num = len(SPConv1.weight.detach()) #num对应该层的卷积核的数量# out：120</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32637015/1667968387144-0764f830-4f68-4fb5-8b6c-f4523ea90811.png#averageHue=%23f6f6f6&amp;clientId=u9bd1aedd-ba8b-4&amp;from=paste&amp;height=48&amp;id=ufc4ff811&amp;originHeight=83&amp;originWidth=1097&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2208&amp;status=done&amp;style=none&amp;taskId=u4a433ba9-1b21-48ae-87d5-af81a238e3a&amp;title=&amp;width=635" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/32637015/1667968423247-44b65ac6-b112-4df7-925f-01d92b60479d.png#averageHue=%23f7f6f6&amp;clientId=u9bd1aedd-ba8b-4&amp;from=paste&amp;height=65&amp;id=uf6d252ba&amp;originHeight=68&amp;originWidth=660&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1447&amp;status=done&amp;style=none&amp;taskId=u657be7ba-c7a8-446d-a6e9-60bcad01433&amp;title=&amp;width=635" alt="image.png"><br>打印所有的卷积核</p><pre><code class="python">for i in range(0,num):    i_kernel = kernel_set[i]    plt.figure(figsize=(20, 17))#figsize指定图片的宽和高    for idx in range(0,9):        plt.subplot(9, 9, idx+1) #将当前图像窗口分为几行几列，当前图片位于第几个        plt.axis(&#39;off&#39;) # 关闭坐标轴        plt.imshow(i_kernel[ :, :].squeeze(0).detach(),cmap=&#39;gray&#39;)    </code></pre><p>输出：<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1667968605641-947eba30-ef1a-4839-8767-21e3b746d37b.png" alt="image.png"></p><pre><code class="python">total_kernel = torch.zeros((1,22,1))for i in range(0,num):    i_kernel = kernel_set[i]    total_kernel +=  i_kerneltotal_kernel = total_kernel/22 # 获得平均权重index_ls = [&#39;Fz&#39;,&#39;FC3&#39;,&#39;FC1&#39;,&#39;FCz&#39;,&#39;FC2&#39;,&#39;FC4&#39;,&#39;C5&#39;,&#39;C3&#39;,&#39;C1&#39;,&#39;Cz&#39;,&#39;C2&#39;,&#39;C4&#39;,&#39;C6&#39;,&#39;CP3&#39;,&#39;CP1&#39;,&#39;CPz&#39;,&#39;CP2&#39;,&#39;CP4&#39;,&#39;P1&#39;,&#39;Pz&#39;,&#39;P2&#39;,&#39;POz&#39;]plt.figure(figsize=(20, 17))#figsize指定图片的宽和高# plt.axis(&#39;off&#39;) # 关闭坐标轴plt.yticks(np.arange(0, 22, 1),index_ls)plt.imshow(total_kernel[ :, :].squeeze(0).detach(),cmap=&#39;bwr&#39;)   </code></pre><p>打印：<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1667968752633-6c82acb0-1822-4cfe-ad6d-20845f7f193a.png" alt="image.png"></p><h2 id="EEG电极"><a href="#EEG电极" class="headerlink" title="EEG电极"></a>EEG电极</h2><p>运动皮层9导联的EEG信号，它们为：FC3，FCz，FC4，C3，CZ，C4，CP3，CPZ，CP4实验范式包括MI任务类型</p><h3 id="BCI-IV-2A电极"><a href="#BCI-IV-2A电极" class="headerlink" title="BCI IV 2A电极"></a>BCI IV 2A电极</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32637015/1667968933442-3e4b5b78-b5a3-4f99-96fc-81c909d21c2f.png#averageHue=%23faf4f2&amp;clientId=u9bd1aedd-ba8b-4&amp;from=paste&amp;height=127&amp;id=u10ff4178&amp;originHeight=127&amp;originWidth=1761&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=139422&amp;status=done&amp;style=none&amp;taskId=u985c98b7-f4b6-4ccc-8adc-f2ffd9588d2&amp;title=&amp;width=1761" alt="image.png"><br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1667968828419-911262e0-5a1f-482d-a29f-f67705483109.png" alt="image.png"><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1667968839571-f8d834ca-fd1a-4c22-9316-9490e8b540a6.png" alt="image.png"><br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1667969237202-f7b5ea4c-7843-4ef4-b751-dd44bceb44e3.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;卷积核可视化&quot;&gt;&lt;a href=&quot;#卷积核可视化&quot; class=&quot;headerlink&quot; title=&quot;卷积核可视化&quot;&gt;&lt;/a&gt;卷积核可视化&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="科研" scheme="https://xingxin-99.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>特征图可视化</title>
    <link href="https://xingxin-99.github.io/2023/09/08/%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://xingxin-99.github.io/2023/09/08/特征图可视化/</id>
    <published>2023-09-08T10:23:42.000Z</published>
    <updated>2023-09-08T10:31:21.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特征图可视化"><a href="#特征图可视化" class="headerlink" title="特征图可视化"></a>特征图可视化</h1><h2 id="特征图可视化代码"><a href="#特征图可视化代码" class="headerlink" title="特征图可视化代码"></a>特征图可视化代码</h2><h3 id="导入相应的包"><a href="#导入相应的包" class="headerlink" title="导入相应的包"></a>导入相应的包</h3><pre><code class="python">import torchimport torchimport torch.nn as nnimport matplotlib.pyplot as pltimport numpy as npimport pickle</code></pre><h3 id="导入网络模型-模型需修改"><a href="#导入网络模型-模型需修改" class="headerlink" title="导入网络模型(模型需修改)"></a>导入网络模型(模型需修改)</h3><p>初始化outputs空数组，将想要输出的特征图添加至outputs中</p><pre><code class="python">class eca_layer(nn.Module):    &quot;&quot;&quot;Constructs a ECA module.    Args:        channel: Number of channels of the input feature map        k_size: Adaptive selection of kernel size    &quot;&quot;&quot;    def __init__(self, channel, k_size=3):        super(eca_layer, self).__init__()        self.avg_pool = nn.AdaptiveAvgPool2d(1)        self.conv = nn.Conv1d(1, 1, kernel_size=k_size, padding=(k_size - 1) // 2, bias=False)        self.sigmoid = nn.Sigmoid()    def forward(self, x):        # x: input features with shape [b, c, h, w]        b, c, h, w = x.size()        # feature descriptor on the global spatial information        y = self.avg_pool(x)        y1 = y.squeeze(-1).transpose(-1, -2)        # Two different branches of ECA module        y2 = self.conv(y1)        y3 = y2.transpose(-1, -2).unsqueeze(-1)        # Multi-scale information fusion        y = self.sigmoid(y)        return x * y.expand_as(x)# %% Support classes for ShallowFBCNet Implementationclass ActSquare(nn.Module):    def __init__(self):        super(ActSquare, self).__init__()        pass    def forward(self, x):        return torch.square(x)class ActLog(nn.Module):    def __init__(self, eps=1e-06):        super(ActLog, self).__init__()        self.eps = eps    def forward(self, x):        return torch.log(torch.clamp(x, min=self.eps))class Conv2dWithConstraint(nn.Conv2d):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(Conv2dWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(Conv2dWithConstraint, self).forward(x)class LinearWithConstraint(nn.Linear):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(LinearWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(LinearWithConstraint, self).forward(x)class MSASNet(nn.Module):    def __init__(self, nChan=22, nTime=1000, nClass=2, dropoutP=0.25, *args, **kwargs):        super(MSASNet, self).__init__()        self.timekernel = 25        self.poolkernel = 85        self.poolstride = 15        self.TC1 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),        )        self.TC2 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),        )        self.TC3 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),        )        self.SP = nn.Sequential(            Conv2dWithConstraint(60, 120, (nChan, 1), max_norm=2, groups=60),            nn.BatchNorm2d(120),            ActSquare(),            nn.AvgPool2d((1, self.poolkernel), (1, self.poolstride)),            ActLog(),        )        self.ECA = eca_layer(120)        self.FC = nn.Sequential(            nn.Dropout(),            nn.Flatten(),            LinearWithConstraint(7440, nClass, max_norm=0.5),  # 3720-&gt;7440            nn.LogSoftmax(dim=1)        )    def forward(self, x):        outputs=[]        x1 = self.TC1(x)        outputs.append(x1)        x2 = self.TC2(x)        outputs.append(x2)        x3 = self.TC3(x)        outputs.append(x3)        x = torch.cat((x1, x2, x3), dim=1)        x = self.SP(x)        outputs.append(x)        x = self.ECA(x)        outputs.append(x)        x = self.FC(x)        return outputs</code></pre><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><pre><code class="python"># 导入模型并加载最好的模型model =MSASNet(nChan=22, nTime=1000, nClass=4)model.load_state_dict(torch.load(&#39;C:/Users/star/Desktop/star/Coding/FBCNet/codes/netInitModels/MSASNet_0.pth&#39;))</code></pre><h3 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h3><pre><code class="python"># 载入数据f = &#39;C:/Users/star/Desktop/star/Coding/FBCNet/data/bci42a/rawPython/00000.dat&#39;with open(f, &#39;rb&#39;) as fp:    d = pickle.load(fp)data = d[&#39;data&#39;]data = torch.from_numpy(data)# 插入维度data = data.unsqueeze(0)# 【1,3,256,256】data = data.unsqueeze(0)out_put = model(data)</code></pre><h3 id="将特征图求平均"><a href="#将特征图求平均" class="headerlink" title="将特征图求平均"></a>将特征图求平均</h3><pre><code class="python">total = []i = 0for feature_map in out_put:    print(i)    print(feature_map.size())    feature_map= feature_map.squeeze(0)    print(feature_map.size())    if i in [0,1,2]:        total_map = torch.zeros((22,1000))    if i in [3,4]:        total_map = torch.zeros((1,62))    for single_map in feature_map:        total_map+=single_map    total.append(total_map)    i=i+1;</code></pre><pre><code class="python">输出：# 0# torch.Size([1, 20, 22, 1000])# torch.Size([20, 22, 1000])# 1# torch.Size([1, 20, 22, 1000])# torch.Size([20, 22, 1000])# 2# torch.Size([1, 20, 22, 1000])# torch.Size([20, 22, 1000])# 3# torch.Size([1, 120, 1, 62])# torch.Size([120, 1, 62])# 4# torch.Size([1, 120, 1, 62])# torch.Size([120, 1, 62])</code></pre><h3 id="绘制特征图"><a href="#绘制特征图" class="headerlink" title="绘制特征图"></a>绘制特征图</h3><pre><code class="python">for i in range(0,5):    plt.figure()    plt.imshow(total[i].detach().numpy(), cmap=&#39;jet&#39;)    plt.show()</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1668000001800-f188e511-67a0-4b5c-8cff-df7d0329a8db.png" alt="image.png"></p><h2 id="特征图可视化修正代码-2023-3-1"><a href="#特征图可视化修正代码-2023-3-1" class="headerlink" title="特征图可视化修正代码(2023.3.1)"></a>特征图可视化修正代码(2023.3.1)</h2><h3 id="导入相应的包-1"><a href="#导入相应的包-1" class="headerlink" title="导入相应的包"></a>导入相应的包</h3><pre><code class="python">import torchimport torchimport torch.nn as nnimport matplotlib.pyplot as pltimport numpy as npimport pickle</code></pre><h3 id="导入网络模型-模型需修改-1"><a href="#导入网络模型-模型需修改-1" class="headerlink" title="导入网络模型(模型需修改)"></a>导入网络模型(模型需修改)</h3><p>初始化outputs空数组，将想要输出的特征图添加至outputs中</p><pre><code class="python">class eca_layer(nn.Module):    &quot;&quot;&quot;Constructs a ECA module.    Args:        channel: Number of channels of the input feature map        k_size: Adaptive selection of kernel size    &quot;&quot;&quot;    def __init__(self, channel, k_size=3):        super(eca_layer, self).__init__()        self.avg_pool = nn.AdaptiveAvgPool2d(1)        self.conv = nn.Conv1d(1, 1, kernel_size=k_size, padding=(k_size - 1) // 2, bias=False)        self.sigmoid = nn.Sigmoid()    def forward(self, x):        # x: input features with shape [b, c, h, w]        b, c, h, w = x.size()        # feature descriptor on the global spatial information        y = self.avg_pool(x)        y1 = y.squeeze(-1).transpose(-1, -2)        # Two different branches of ECA module        y2 = self.conv(y1)        y3 = y2.transpose(-1, -2).unsqueeze(-1)        # Multi-scale information fusion        y = self.sigmoid(y)        return x * y.expand_as(x)# %% Support classes for ShallowFBCNet Implementationclass ActSquare(nn.Module):    def __init__(self):        super(ActSquare, self).__init__()        pass    def forward(self, x):        return torch.square(x)class ActLog(nn.Module):    def __init__(self, eps=1e-06):        super(ActLog, self).__init__()        self.eps = eps    def forward(self, x):        return torch.log(torch.clamp(x, min=self.eps))class Conv2dWithConstraint(nn.Conv2d):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(Conv2dWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(Conv2dWithConstraint, self).forward(x)class LinearWithConstraint(nn.Linear):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(LinearWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(LinearWithConstraint, self).forward(x)class MSASNet(nn.Module):    def __init__(self, nChan=22, nTime=1000, nClass=2, dropoutP=0.25, *args, **kwargs):        super(MSASNet, self).__init__()        self.timekernel = 25        self.poolkernel = 85        self.poolstride = 15        self.TC1 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),        )        self.TC2 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),        )        self.TC3 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),        )        self.SP = nn.Sequential(            Conv2dWithConstraint(60, 120, (nChan, 1), max_norm=2, groups=60),            nn.BatchNorm2d(120),            ActSquare(),            nn.AvgPool2d((1, self.poolkernel), (1, self.poolstride)),            ActLog(),        )        self.ECA = eca_layer(120)        self.FC = nn.Sequential(            nn.Dropout(),            nn.Flatten(),            LinearWithConstraint(7440, nClass, max_norm=0.5),  # 3720-&gt;7440            nn.LogSoftmax(dim=1)        )    def forward(self, x):        outputs=[]        x1 = self.TC1(x)        outputs.append(x1)        x2 = self.TC2(x)        outputs.append(x2)        x3 = self.TC3(x)        outputs.append(x3)        x = torch.cat((x1, x2, x3), dim=1)        x = self.SP(x)        outputs.append(x)        x = self.ECA(x)        outputs.append(x)        x = self.FC(x)        return outputs</code></pre><h3 id="加载模型-1"><a href="#加载模型-1" class="headerlink" title="加载模型"></a>加载模型</h3><pre><code class="python"># 导入模型并加载最好的模型model =MSASNet(nChan=22, nTime=1000, nClass=4)model.load_state_dict(torch.load(&#39;C:/Users/star/Desktop/star/Coding/FBCNet/codes/netInitModels/MSASNet_0.pth&#39;))</code></pre><h3 id="载入数据-1"><a href="#载入数据-1" class="headerlink" title="载入数据"></a>载入数据</h3><pre><code class="python"># 载入数据f = &#39;C:/Users/BCIgroup/Desktop/star/Coding/FBCNet/FBCNet-master/data/bci42a/rawPython/00000.dat&#39;# f = &#39;C:/Users/star/Desktop/star/Coding/FBCNet/data/bci42a/rawPython/00000.dat&#39;with open(f, &#39;rb&#39;) as fp:    d = pickle.load(fp)data = d[&#39;data&#39;]label = d[&#39;label&#39;]data = torch.from_numpy(data)# 插入维度data = data.unsqueeze(0)# 【1,3,256,256】data = data.unsqueeze(0)out_put = model(data)</code></pre><h3 id="将特征图求平均-1"><a href="#将特征图求平均-1" class="headerlink" title="将特征图求平均"></a>将特征图求平均</h3><pre><code class="python">total = []i = 0for feature_map in out_put:    print(i)    print(feature_map.size())    feature_map= feature_map.squeeze(0)    print(feature_map.size())    if i in [0,1,2]:        total_map = torch.zeros((22,1000))    if i in [3,4]:        total_map = torch.zeros((1,62))    for single_map in feature_map:        total_map+=torch.abs(single_map)    matrix = total_map.detach().numpy()/feature_map.size(0)    # point 代表每多少点的数据压缩为一个数据    point = 10    # 将每列的数据重塑为point个元素的子矩阵    sub_matrices = matrix.reshape(matrix.shape[0], -1, point)    # 计算每个子矩阵的平均值    averages = np.mean(sub_matrices, axis=2)    # 将每列的数据重塑回原始形状    result = averages.reshape(matrix.shape[0], -1)    total.append(result)    i=i+1;</code></pre><h3 id="绘制特征图-1"><a href="#绘制特征图-1" class="headerlink" title="绘制特征图"></a>绘制特征图</h3><pre><code class="python"># for i in range(0,5):i = 0fig, axs = plt.subplots(nrows=3 , ncols=1)fig.subplots_adjust(hspace=0.5)# index_ls = [&#39;Fz&#39;,&#39;FC3&#39;,&#39;FC1&#39;,&#39;FCz&#39;,&#39;FC2&#39;,&#39;FC4&#39;,&#39;C5&#39;,&#39;C3&#39;,&#39;C1&#39;,&#39;Cz&#39;,&#39;C2&#39;,&#39;C4&#39;,&#39;C6&#39;,&#39;CP3&#39;,&#39;CP1&#39;,&#39;CPz&#39;,&#39;CP2&#39;,&#39;CP4&#39;,&#39;P1&#39;,&#39;Pz&#39;,&#39;P2&#39;,&#39;POz&#39;]for ax in axs.flat:  #归一化    d = total[i]    d_normalized = (d - np.min(d)) / (np.max(d) - np.min(d))    im = ax.imshow(d_normalized, cmap=&#39;jet&#39;)    # 设置X轴和Y轴的标签    ax.set_ylabel(&#39;Electrode&#39;)    ax.set_xlabel(&#39;Time(s)&#39;)    # 设置X轴和Y轴的刻度位置    v = 1000/(4*point)    # 让刻度线在最左侧    xx = [0,v,2*v,3*v,4*v]    ax.set_xticks([index - 0.5 for index in xx],rotation=&#39;horizontal&#39;)    ax.set_yticks([])    # ax.set_yticks(np.arange(total[i].shape[0]))    # 设置X轴和Y轴的刻度标签    # ax.margins(0.1)    ax.tick_params(axis=&#39;y&#39;, labelsize=4)    # ax.tick_params(axis=&#39;x&#39;, labelsize=6)    ax.set_xticklabels([&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;,&#39;4&#39;])    # ax.set_yticklabels(index_ls)    i = i + 1;#对所有子图绘制colorbarcbar = fig.colorbar(im, ax=axs)plt.savefig(&#39;C:/Users/BCIgroup/Desktop/star/output.png&#39;, dpi=300, bbox_inches=&#39;tight&#39;)plt.savefig(&#39;C:/Users/BCIgroup/Desktop/star/output.pdf&#39;, dpi=300, bbox_inches=&#39;tight&#39;)plt.show()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;特征图可视化&quot;&gt;&lt;a href=&quot;#特征图可视化&quot; class=&quot;headerlink&quot; title=&quot;特征图可视化&quot;&gt;&lt;/a&gt;特征图可视化&lt;/h1&gt;&lt;h2 id=&quot;特征图可视化代码&quot;&gt;&lt;a href=&quot;#特征图可视化代码&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="科研" scheme="https://xingxin-99.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>热力图可视化</title>
    <link href="https://xingxin-99.github.io/2023/09/08/%E7%83%AD%E5%8A%9B%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://xingxin-99.github.io/2023/09/08/热力图可视化/</id>
    <published>2023-09-08T10:23:22.000Z</published>
    <updated>2023-09-08T10:36:27.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热力图可视化"><a href="#热力图可视化" class="headerlink" title="热力图可视化"></a>热力图可视化</h1><h2 id="热力图可视化代码"><a href="#热力图可视化代码" class="headerlink" title="热力图可视化代码"></a>热力图可视化代码</h2><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><pre><code class="python">import torchimport torch.nn as nnimport scipy.io as sioimport numpy as npimport torch.optim as optimimport matplotlib.pyplot as pltfrom matplotlib.collections import LineCollectionfrom scipy.integrate import simpsfrom mne.time_frequency import psd_array_multitaperimport matplotlib.gridspec as gridspecimport picklefrom pytorch_grad_cam import GradCAM</code></pre><h3 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h3><pre><code class="python">class eca_layer(nn.Module):    &quot;&quot;&quot;Constructs a ECA module.    Args:        channel: Number of channels of the input feature map        k_size: Adaptive selection of kernel size    &quot;&quot;&quot;    def __init__(self, channel, k_size=3):        super(eca_layer, self).__init__()        self.avg_pool = nn.AdaptiveAvgPool2d(1)        self.conv = nn.Conv1d(1, 1, kernel_size=k_size, padding=(k_size - 1) // 2, bias=False)        self.sigmoid = nn.Sigmoid()    def forward(self, x):        # x: input features with shape [b, c, h, w]        b, c, h, w = x.size()        # feature descriptor on the global spatial information        y = self.avg_pool(x)        y1 = y.squeeze(-1).transpose(-1, -2)        # Two different branches of ECA module        y2 = self.conv(y1)        y3 = y2.transpose(-1, -2).unsqueeze(-1)        # Multi-scale information fusion        y = self.sigmoid(y)        return x * y.expand_as(x)# %% Support classes for ShallowFBCNet Implementationclass ActSquare(nn.Module):    def __init__(self):        super(ActSquare, self).__init__()        pass    def forward(self, x):        return torch.square(x)class ActLog(nn.Module):    def __init__(self, eps=1e-06):        super(ActLog, self).__init__()        self.eps = eps    def forward(self, x):        return torch.log(torch.clamp(x, min=self.eps))class Conv2dWithConstraint(nn.Conv2d):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(Conv2dWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(Conv2dWithConstraint, self).forward(x)class LinearWithConstraint(nn.Linear):    def __init__(self, *args, doWeightNorm=True, max_norm=1, **kwargs):        self.max_norm = max_norm        self.doWeightNorm = doWeightNorm        super(LinearWithConstraint, self).__init__(*args, **kwargs)    def forward(self, x):        if self.doWeightNorm:            self.weight.data = torch.renorm(                self.weight.data, p=2, dim=0, maxnorm=self.max_norm            )        return super(LinearWithConstraint, self).forward(x)class MSASNet(nn.Module):    def __init__(self, nChan=22, nTime=1000, nClass=2, dropoutP=0.25, *args, **kwargs):        super(MSASNet, self).__init__()        self.timekernel = 25        self.poolkernel = 85        self.poolstride = 15        self.TC1 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),        )        self.TC2 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),        )        self.TC3 = nn.Sequential(            Conv2dWithConstraint(1, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),            Conv2dWithConstraint(20, 20, (1, self.timekernel), padding=(0, (self.timekernel - 1) // 2), max_norm=2,                                 groups=20),        )        self.SP = nn.Sequential(            Conv2dWithConstraint(60, 120, (nChan, 1), max_norm=2, groups=60),            nn.BatchNorm2d(120),            ActSquare(),            nn.AvgPool2d((1, self.poolkernel), (1, self.poolstride)),            ActLog(),        )        self.ECA = eca_layer(120)        self.FC = nn.Sequential(            nn.Dropout(),            nn.Flatten(),            LinearWithConstraint(7440, nClass, max_norm=0.5),  # 3720-&gt;7440            nn.LogSoftmax(dim=1)        )    def forward(self, x):        x1 = self.TC1(x)        x2 = self.TC2(x)        x3 = self.TC3(x)        x = torch.cat((x1, x2, x3), dim=1)        x = self.SP(x)        x = self.ECA(x)        x = self.FC(x)        return x</code></pre><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><pre><code class="python"># 导入模型并加载最好的模型model =MSASNet(nChan=22, nTime=1000, nClass=4)model.load_state_dict(torch.load(&#39;C:/Users/star/Desktop/star/Coding/FBCNet/codes/netInitModels/MSASNet_0.pth&#39;))target_layer = [model.TC1[0]]</code></pre><h3 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h3><pre><code class="python"># 载入数据f = &#39;C:/Users/star/Desktop/star/Coding/FBCNet/data/bci42a/rawPython/00000.dat&#39;with open(f, &#39;rb&#39;) as fp:    d = pickle.load(fp)data = d[&#39;data&#39;]label = d[&#39;label&#39;]data = torch.from_numpy(data)# 插入维度data = data.unsqueeze(0)# 【1,3,256,256】data = data.unsqueeze(0)</code></pre><h3 id="CAM计算"><a href="#CAM计算" class="headerlink" title="CAM计算"></a>CAM计算</h3><pre><code class="python">cam = GradCAM(model=model, target_layers=target_layer, use_cuda=True)target_category = labelgrayscale_cam = cam(input_tensor=data)[0]</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32637015/1668000234684-f0436ce9-5b3b-4655-a82d-127f3dbb98d2.png#averageHue=%23f6f5f5&amp;clientId=u8f29ebf6-8a59-4&amp;from=paste&amp;height=66&amp;id=u8dacebdb&amp;originHeight=66&amp;originWidth=442&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1334&amp;status=done&amp;style=none&amp;taskId=ub93c0a60-ee3e-42f5-9a36-4aebf6b4aba&amp;title=&amp;width=442" alt="image.png"></p><h3 id="相关参数设置"><a href="#相关参数设置" class="headerlink" title="相关参数设置"></a>相关参数设置</h3><pre><code class="python">rawdata = d[&#39;data&#39;]channelnum=22samplelength=1000</code></pre><h3 id="图像设置"><a href="#图像设置" class="headerlink" title="图像设置"></a>图像设置</h3><pre><code class="python">fig = plt.figure(figsize=(14,6))gridlayout = gridspec.GridSpec(ncols=2, nrows=3, figure=fig,wspace=0.2, hspace=0.5)a = fig.add_subplot(gridlayout[0:3,1])# a = fig.add_axes([0,0,1,1])thespan=np.percentile(rawdata,98)yttics=np.zeros(channelnum)for i in range(channelnum):    yttics[i]=i*thespana.set_ylim([-thespan,thespan*channelnum])   # 设置坐标轴范围a.set_xlim([0,1001])labels = [&#39;Fz&#39;,&#39;FC3&#39;,&#39;FC1&#39;,&#39;FCz&#39;,&#39;FC2&#39;,&#39;FC4&#39;,&#39;C5&#39;,&#39;C3&#39;,&#39;C1&#39;,&#39;Cz&#39;,&#39;C2&#39;,&#39;C4&#39;,&#39;C6&#39;,&#39;CP3&#39;,&#39;CP1&#39;,&#39;CPz&#39;,&#39;CP2&#39;,&#39;CP4&#39;,&#39;P1&#39;,&#39;Pz&#39;,&#39;P2&#39;,&#39;POz&#39;]plt.sca(a) #选择子图plt.yticks(yttics, labels)</code></pre><h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><pre><code class="python">xx=np.arange(1,samplelength+1)for i in range(0,channelnum):    y=rawdata[i,:]+thespan*(i)    dydx=grayscale_cam[i,:]    points = np.array([xx, y]).T.reshape(-1, 1, 2)    segments = np.concatenate([points[:-1], points[1:]], axis=1)    norm = plt.Normalize(-1, 1)    lc = LineCollection(segments, cmap=&#39;YlGnBu&#39;, norm=norm)    lc.set_array(dydx)    lc.set_linewidth(2)    a.add_collection(lc)plt.show()</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1668150773780-a0548a99-52da-4a3f-9067-27f3dca055b1.png" alt="Figure_1.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;热力图可视化&quot;&gt;&lt;a href=&quot;#热力图可视化&quot; class=&quot;headerlink&quot; title=&quot;热力图可视化&quot;&gt;&lt;/a&gt;热力图可视化&lt;/h1&gt;&lt;h2 id=&quot;热力图可视化代码&quot;&gt;&lt;a href=&quot;#热力图可视化代码&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="科研" scheme="https://xingxin-99.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>得物二面</title>
    <link href="https://xingxin-99.github.io/2023/09/03/%E5%BE%97%E7%89%A9%E4%BA%8C%E9%9D%A2/"/>
    <id>https://xingxin-99.github.io/2023/09/03/得物二面/</id>
    <published>2023-09-03T09:07:14.000Z</published>
    <updated>2023-09-03T09:26:25.451Z</updated>
    
    <content type="html"><![CDATA[<p>二面时间：2023/9/2 10：50 大约30min</p><ol><li>自我介绍</li><li>你的项目经历主要是Java开发，那你为什么投递测试开发这个方向呢？</li><li>计算机科学与技术这个专业会去学习测试相关的课程吗？</li><li>对于软件测试这个方向，你都了解哪些内容？</li><li>刚才有提到白盒测试与黑盒测试，请详细介绍一下白盒测试和黑盒测试的方法有哪些？</li><li>这些都去尝试和实践过吗？</li><li>接口测试的核心点是什么？</li><li>接口测试了解哪些类型？</li><li>不是测试工具，是了解哪些类型的接口？</li><li>自测的话，那么测试用例你是如何编写的？</li><li>不是设计用例的具体细节，你觉得什么样的测试用例可以称之为一个好的测试用例？</li><li>你做自测时，有没有什么让你比较深刻的问题？</li><li>对测试开发这个行业现状和技术，还有最新的技术实践有做过学习和了解吗？</li><li>那测试开发的行业动态了解吗？</li><li>你觉得你个人的优势在哪里？</li><li>反问：一些关于测试学习的建议</li><li>建议：首先确定自己是否要走测试开发这个方向，然后去系统的学习测试的理论知识。另外要去了解行业的最新动态和实践。比如说举个例子，做测试、做自动化，这个是一个非常普遍的一个技术手段了。什么是自动化？对吧？嗯，现在工具有很多种，哪一种是比较这个比较好的，或者说比较通用的。那自动化这个工具它演进从一开始到现在它的演进过程是什么？不要只了解说现在是你会用，那你不知道为什么它慢慢会演变成这个样子，对吧？这个是可能会区分出我们对于候选人，当然未必是校招，可能对于社招来说也未必都了解的这么好。嗯，它可以区分那个一个层次的。还有行业目前的现状。另一方面对于目前行业的现状，对吧？行业的最新的一些实践。</li><li>闲聊</li><li>目前会看新闻吗？</li><li>对得物有了解吗？</li><li>平时一般购物会用什么平台？</li><li>各自体会怎么样？</li><li>有考虑过未来的职业发展吗？希望在哪个城市或者哪个行业方向？</li><li>对于目前互联网普遍加班严重这个现象，你怎么看？</li></ol>]]></content>
    
    <summary type="html">
    
      得物二面面试官更关注于面试者对测试的了解以及对整个测试行业动态的关注，面完收获颇丰
    
    </summary>
    
      <category term="面试" scheme="https://xingxin-99.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Bean对象的作用域</title>
    <link href="https://xingxin-99.github.io/2023/08/29/Spring-Bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://xingxin-99.github.io/2023/08/29/Spring-Bean对象的作用域/</id>
    <published>2023-08-29T13:13:08.000Z</published>
    <updated>2023-08-29T13:15:56.360Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>singleton</strong><br>单例bean对象，每个Bean对象在每个Spring容器中只存在一个。<br>当Spring容器启动时，它会读取并解析<code>BeanDefination</code>，然后根据<code>BeanDefination</code>创建Bean实例，并把这些实例保存在<code>singletonCache</code>（单例注册表<code>private final Map singletonCache=new HashMap()</code> ，其中Bean的名称（或ID）充当键，Bean实例充当值）。当其他组件请求某一Bean时，Spring会首先检查在单例注册表中是否存在该Bean，如果存在，则直接返回该Bean对象的实例，否则将会去创建该Bean的实例对象。</li><li><strong>prototype</strong><br>每进行一次依赖注入，或者每调用一次<code>getBean()</code>方法都会创建新的Bean对象。<br>与singleton不同的是，当其他组件请求某一Bean时，会在每次请求时都调用<code>createBean(beanName,mergedBeanDefinition,args)</code>来创建一个新的Bean实例。</li><li><strong>request</strong><br>每次http请求都会创建一个Bean</li><li><strong>session</strong><br>每个会话都会创建一个Bean</li><li><strong>websocket</strong><br>一个websocket对应一个Bean</li><li><strong>global-session</strong><br>在一个全局的http session中，一个Bean定义对应一个实例</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;singleton&lt;/strong&gt;&lt;br&gt;单例bean对象，每个Bean对象在每个Spring容器中只存在一个。&lt;br&gt;当Spring容器启动时，它会读取并解析&lt;code&gt;BeanDefination&lt;/code&gt;，然后根据&lt;code&gt;Bean
      
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>对依赖注入的理解</title>
    <link href="https://xingxin-99.github.io/2023/08/29/%E5%AF%B9%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://xingxin-99.github.io/2023/08/29/对依赖注入的理解/</id>
    <published>2023-08-29T13:12:45.000Z</published>
    <updated>2023-08-29T13:15:09.988Z</updated>
    
    <content type="html"><![CDATA[<p>DI是为了实现控制反转的思想，其中依赖指的是对象与对象之间的关联关系，注入指的是一种数据传递行为，通过注入让对象和对象产生关系。通过依赖注入的方式可以去除Java类的直接依赖关系，实现松耦合。如果不使用依赖注入，那么对象与对象就交由开发人员来负责。比如优惠券父类引用指向折扣劵子类对象，如果想要替换折扣劵为满减劵，就需要由开发人员修改所有的折扣劵处的引用代码。而通过依赖注入就无须在代码中创建被调用对象，那么对象与对象之间关系的注入交由容器来负责，我想要优惠券的父类引用从指向折扣劵改为指向满减劵的子类对象，那么只需要修改配置文件即可。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>不使用依赖注入，对象与对象之间紧密耦合。</strong></p><pre><code class="java">class Player{      Weapon weapon;      Player(){          // 与 Sword类紧密耦合        this.weapon = new Sword();      }      public void attack() {        weapon.attack();    }}   </code></pre><p>例如，玩家的武器只能是剑Sword，而不能把Sword替换成枪Gun。要把Sword改为Gun，所有涉及到的代码都要修改。<br><strong>依赖注入是一种消除类之间依赖关系的设计模式。</strong><br>例如，A类要依赖B类，A类不再直接创建B类，而是把这种依赖关系配置在外部xml文件（或java config文件）中，然后由Spring容器根据配置信息创建、管理bean类。</p><pre><code class="java">class Player{      Weapon weapon;      // weapon 被注入进来    Player(Weapon weapon){          this.weapon = weapon;      }      public void attack() {        weapon.attack();    }    public void setWeapon(Weapon weapon){          this.weapon = weapon;      }  </code></pre><p>如上所示，Weapon类的实例并不在代码中创建，而是外部通过构造函数传入，传入类型是<strong>父类</strong>Weapon，所以传入的对象类型可以是任何Weapon子类。</p><h3 id="依赖注入的实现方式"><a href="#依赖注入的实现方式" class="headerlink" title="依赖注入的实现方式"></a>依赖注入的实现方式</h3><ol><li><strong>Setter方法注入</strong><br>底层通过反射机制调用属性的set方法来将被依赖对象注入给依赖类，这种方式要求属性必须对外提高set方法。<br><strong>优点：</strong> 灵活。可以选择性地注入需要的对象。<br><strong>缺点：</strong> 依赖对象实例化完成后由于尚未注入被依赖对象，因此还不能使用。  </li><li><strong>构造函数注入</strong><br>将被依赖对象通过构造函数的参数传入给依赖对象。<br><strong>优点：</strong> 对象实例化完成后便可获得可使用的对象。<br><strong>缺点：</strong> 当需要注入的对象很多时，构造器参数列表将会很长； 不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。  <h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><a href="https://zhuanlan.zhihu.com/p/67032669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67032669</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DI是为了实现控制反转的思想，其中依赖指的是对象与对象之间的关联关系，注入指的是一种数据传递行为，通过注入让对象和对象产生关系。通过依赖注入的方式可以去除Java类的直接依赖关系，实现松耦合。如果不使用依赖注入，那么对象与对象就交由开发人员来负责。比如优惠券父类引用指向折扣
      
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>对IOC的理解</title>
    <link href="https://xingxin-99.github.io/2023/08/29/%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://xingxin-99.github.io/2023/08/29/对IOC的理解/</id>
    <published>2023-08-29T13:12:30.000Z</published>
    <updated>2023-08-29T13:15:07.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对IOC的理解"><a href="#对IOC的理解" class="headerlink" title="对IOC的理解"></a>对IOC的理解</h2><p>IOC全称为控制反转，它是面向对象编程的一种设计思想，主要是为了降低程序的耦合度，提高程序的扩展力，达到OCP与DIP原则。<br><strong>IOC的核心</strong>：对象创建权以及对象与对象关系的管理权交由第三方容器来负责。<br><strong>IOC的常见实现方式：</strong>依赖注入<br><strong>IOC的主要优点</strong>：</p><ol><li>降低代码之间的耦合度</li><li>集中资源统一管理，简化开发</li></ol><p>软件系统在没有引⼊ IOC 容器之前，对象 A 依赖于对象 B，那么对象 A 在初始化或者运⾏到某⼀点的时候，⾃⼰必须主动去创建对象 B 或者使⽤已经创建的对象 B。⽆论是创建还是使⽤对象 B，控制权都在⾃⼰⼿上。<br>软件系统在引⼊IOC容器之后，这种情形就完全改变了，由于 IOC 容器的加⼊，对象 A 与对象 B 之间失去了直接 联系，所以，当对象 A 运⾏到需要对象 B 的时候，IOC 容器会主动创建⼀个对象 B 注⼊到对象 A 需要的地⽅。 通过前后的对⽐，我们不难看出来：对象 A 获得依赖对象 B 的过程，由主动⾏为变为了被动⾏为，控制权颠倒过 来了，这就是“控制反转”这个名称的由来。  </p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>有A、B两个类，其中A依赖于B</p><pre><code class="java">class A{    private B b;    A(int n){        this.b = new B(n);    }}class B{    private int n;    B(int n){        this.n = n;    }}public static vlid main(){  A a = new A(1);}</code></pre><p>现在要对B类业务进行更改，那么创建B的业务代码处都要进行更改，因此代码整体改动较大</p><pre><code class="java">class A{    private B b;    A(int n,int m){        this.b = new B(n,m);    }}class B{    private int n;    private int m;    B(int n,int m){        this.n = n;        this.m = m;    }}public static vlid main(){  A a = new A(1,2);}</code></pre><p>但是如果对象的创建过程以及对象与对象关系的导入过程交由第三方容器来管理，那么对B的业务进行扩展，就不会再影响到A的代码。比如下面代码就实现了IOC思想，将对象的创建以及对象与对象关系的导入交由main函数来管理。</p><pre><code class="java">class A{    private B b;    A(B b){        this.b = b;    }}class B{    private int n;    B(int n){        this.n = n;    }}public static vlid main(){    B b = new B(1);  A a = new A(b);}</code></pre><p>再对B进行功能扩展时，并不影响到A，仅是在main函数（即容器，通过配置文件更改）中创建B对象时发生了变化，因此实现了A与B的解耦合。</p><pre><code class="java">class A{    private B b;    A(B b){        this.b = b;    }}class B{    private int n;    private int m;    B(int n,int m){        this.n = n;        this.m = m;    }}public static vlid main(){    B b = new B(1,2)  A a = new A(b);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对IOC的理解&quot;&gt;&lt;a href=&quot;#对IOC的理解&quot; class=&quot;headerlink&quot; title=&quot;对IOC的理解&quot;&gt;&lt;/a&gt;对IOC的理解&lt;/h2&gt;&lt;p&gt;IOC全称为控制反转，它是面向对象编程的一种设计思想，主要是为了降低程序的耦合度，提高程序的扩展力，
      
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Bean对象的生命周期</title>
    <link href="https://xingxin-99.github.io/2023/08/29/Bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://xingxin-99.github.io/2023/08/29/Bean对象的生命周期/</id>
    <published>2023-08-29T10:15:46.000Z</published>
    <updated>2023-08-29T10:33:53.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean对象的生命周期"><a href="#Bean对象的生命周期" class="headerlink" title="Bean对象的生命周期"></a>Bean对象的生命周期</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1665394697870-15de433a-8d50-4b31-9b75-b2ca7090c1c6.png" alt></p><ol><li><strong>实例化Bean</strong><br>当Spring启动时，会查找并加载需要被Spring管理的Bean（基于注解方式的话，会查找加了@Bean、@Controller、@Service…的类）。通过BeanDefinitionReader这个接口解析xml配置、配置类或其他的一些方式定义的类，得到BeanDefinition。使用BeanFactory通过反射对Bean进行实例化。</li><li><strong>依赖注入</strong><br>对bean中的属性进行赋值，通过setter方法注入，比如对加了@Autowire 注解的属性注入 </li><li><strong>处理Aware接口（Aware回调接口，让bean向容器表明它们需要某种基础设施依赖）</strong><br>Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean。  比如这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值  </li><li><strong>调用BeanPostProcessor的前置处理方法</strong><br>自定义初始化前逻辑，比如日志检查、属性修改等</li><li><strong>执行初始化方法</strong><br>检查Bean是否实现了InitializingBean接口或者在配置文件中配置了init-method属性，如果配置了，则自动调用配置的初始化方法。通过执行初始化方法，可以使Bean在被程序使用之前执行一些自定义初始化操作，比如资源加载、连接数据库等。  </li><li><strong>调用BeanPostProcessor的后置处理方法</strong><br>主要对bean进行增强。AOP就是通过BeanPostProcessor的后置方法来实现对Bean对象的代理。</li><li><strong>使用Bean</strong><br>经过上述步骤后Bean已经被创建，现在可以使用这个Bean了</li><li><strong>销毁Bean</strong><br>如果Bean实现了DisposableBean这个接口，会自动其实现的destroy()方法。 如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</li></ol><p>参考：<br><a href="https://blog.csdn.net/Bronze5/article/details/105902892" target="_blank" rel="noopener">https://blog.csdn.net/Bronze5/article/details/105902892</a><br><a href="https://blog.csdn.net/qq_57434877/article/details/123714044" target="_blank" rel="noopener">https://blog.csdn.net/qq_57434877/article/details/123714044</a></p>]]></content>
    
    <summary type="html">
    
      Bean对象的生命周期
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://xingxin-99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>对AOP的理解</title>
    <link href="https://xingxin-99.github.io/2023/08/29/%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://xingxin-99.github.io/2023/08/29/对AOP的理解/</id>
    <published>2023-08-29T09:21:38.000Z</published>
    <updated>2023-08-29T10:33:59.607Z</updated>
    
    <content type="html"><![CDATA[<p>AOP指的是一种面向切面编程的思想，它把与业务无关的代码（比如事务管理、日志管理等系统服务）抽取出来单独封装成一个个切面，然后在运行时通过动态代理的方式织入到业务代码中。通过AOP可以使代码复用性增强，同时使开发人员专注于核心业务代码的编写，而不需要在编写核心业务代码时还需处理交叉业务。<br>AOP真正强大之处在于，它可以在系统业务逻辑固定情况下，在方法前后等一些位置处根据需求添加一些代码来对业务逻辑进行增强或修改，实现了想对功能扩展就增加功能模块，想去掉该功能就去掉该功能模块，解耦力度很大，灵活度很高。同时也满足了设计模式中的开闭原则。<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1665732609757-d8ae52ba-915e-49cf-9ef4-c7bcada0d601.png" alt></p><h3 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h3><ol><li><strong>连接点Jointpoint</strong><br>在程序执行过程中，可以织入切面的位置。比如方法的执行前后，异常抛出之后等位置。</li><li><strong>切点Pointcut</strong><br>在程序执行过程中，真正织入切面的位置。（什么地方）</li><li><strong>通知Advice</strong><br>通知其实就是要进行增强的代码（在什么时候要做什么增强）<br>通知包括了前置通知（@Before 目标方法执行之前的通知）、后置通知（@AfterReturning 目标方法执行之后的通知）、环绕通知（@Around 目标方法之前添加通知，同时目标方法执行之后添加通知。）、异常通知（@AfterThrowing 发生异常之后执行的通知）、最终通知（@After 放在finally语句块中的通知）</li><li><strong>切面Aspect</strong><br>切点+通知（在什么地方，什么时候，做了什么增强。）</li><li><strong>织入Weaving</strong><br>把通知应用到目标对象上的过程</li><li><strong>代理对象Proxy</strong><br>目标对象被织入通知后产生的新对象</li><li><strong>目标对象Target</strong><br>要被织入通知的对象</li></ol><h3 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h3><p>切点表达式用来定义通知（Advice）往哪些方法上切入。<br>切入点表达式语法格式：</p><pre><code class="java">execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])</code></pre><ol><li><strong>访问控制权限修饰符（可选项）</strong><ol><li>没写，就是4个权限都包括。</li><li>写public就表示只包括公开的方法。</li></ol></li><li><strong>返回值类型（必填项）</strong><ol><li>*表示返回值类型任意。</li></ol></li><li><strong>全限定类名（可选项）</strong><ol><li>两个点“..”代表当前包以及子包下的所有类。</li><li>省略时表示所有的类。</li></ol></li><li><strong>方法名（必填项）</strong><ol><li>*表示所有方法</li><li>set*表示所有的set方法</li></ol></li><li><strong>形式参数列表（必填项）</strong><ol><li>() 表示没有参数的方法</li><li>(..) 参数类型和个数随意的方法</li><li>(*) 只有一个参数的方法</li><li>(*, String) 第一个参数类型随意，第二个参数是String的。</li></ol></li><li><strong>异常（可选项）</strong><ol><li>省略时表示任意异常类型。<pre><code class="java">execution(public * com.powernode.mall.service.*.delete*(..))</code></pre></li></ol></li></ol><h3 id="AOP案例：安全日志"><a href="#AOP案例：安全日志" class="headerlink" title="AOP案例：安全日志"></a>AOP案例：安全日志</h3><blockquote><p>需求：项目开发结束了，已经上线了。运行正常。客户提出了新的需求：凡事在系统中进行修改操作的，删除操作的，新增操作的，都要把这个人记录下来。</p></blockquote><pre><code class="java">package com.powernode.spring6.biz;import org.springframework.stereotype.Component;@Component//用户业务public class UserService {    public void getUser(){        System.out.println(&quot;获取用户信息&quot;);    }    public void saveUser(){        System.out.println(&quot;保存用户&quot;);    }    public void deleteUser(){        System.out.println(&quot;删除用户&quot;);    }    public void modifyUser(){        System.out.println(&quot;修改用户&quot;);    }}</code></pre><pre><code class="java">package com.powernode.spring6.biz;import org.springframework.stereotype.Component;// 商品业务类@Componentpublic class ProductService {    public void getProduct(){        System.out.println(&quot;获取商品信息&quot;);    }    public void saveProduct(){        System.out.println(&quot;保存商品&quot;);    }    public void deleteProduct(){        System.out.println(&quot;删除商品&quot;);    }    public void modifyProduct(){        System.out.println(&quot;修改商品&quot;);    }}</code></pre><pre><code class="java">package com.powernode.spring6.biz;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectpublic class SecurityAspect {    @Pointcut(&quot;execution(* com.powernode.spring6.biz..save*(..))&quot;)    public void savePointcut(){}    @Pointcut(&quot;execution(* com.powernode.spring6.biz..delete*(..))&quot;)    public void deletePointcut(){}    @Pointcut(&quot;execution(* com.powernode.spring6.biz..modify*(..))&quot;)    public void modifyPointcut(){}    @Before(&quot;savePointcut() || deletePointcut() || modifyPointcut()&quot;)    public void beforeAdivce(JoinPoint joinpoint){        System.out.println(&quot;XXX操作员正在操作&quot;+joinpoint.getSignature().getName()+&quot;方法&quot;);    }}</code></pre><pre><code class="java">@Testpublic void testSecurity(){    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Configuration.class);    UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class);    ProductService productService = applicationContext.getBean(&quot;productService&quot;, ProductService.class);    userService.getUser();    userService.saveUser();    userService.deleteUser();    userService.modifyUser();    productService.getProduct();    productService.saveProduct();    productService.deleteProduct();    productService.modifyProduct();}</code></pre><p>执行结果<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1665901327786-9bfab382-61a3-4d1e-abe5-728b242eb3a2.png" alt><br>参考：<br><a href="https://www.yuque.com/dujubin/ltckqu/kipzgd#Cd1wT" target="_blank" rel="noopener">https://www.yuque.com/dujubin/ltckqu/kipzgd#Cd1wT</a><br><a href="https://blog.csdn.net/duzhe2905/article/details/105938187" target="_blank" rel="noopener">https://blog.csdn.net/duzhe2905/article/details/105938187</a></p><p><a href="https://blog.csdn.net/rod0320/article/details/123288057?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D" target="_blank" rel="noopener">https://blog.csdn.net/rod0320/article/details/123288057?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D</a><br><a href="https://blog.csdn.net/rod0320/article/details/123288057?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D" target="_blank" rel="noopener">https://blog.csdn.net/rod0320/article/details/123288057?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D</a></p>]]></content>
    
    <summary type="html">
    
      什么是AOP？AOP相关术语？AOP实际应用
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
      <category term="AOP" scheme="https://xingxin-99.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring特点</title>
    <link href="https://xingxin-99.github.io/2023/08/29/Spring%E7%89%B9%E7%82%B9/"/>
    <id>https://xingxin-99.github.io/2023/08/29/Spring特点/</id>
    <published>2023-08-29T05:02:21.000Z</published>
    <updated>2023-08-29T05:18:36.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>侵入式框架：引入了框架，对现有的类的结构有影响，需要实现框架某些接口或者基础某些特定的类。侵入式让用户的代码对框架产生了依赖，不利于代码的复用，当去除框架的时候，程序就无法运行。<br>非侵入式：使用一个新的技术不会或者基本不改变原有代码结构,原有代码不作任何修改即可。</p></blockquote><ol><li><strong>轻量</strong><br>完整的Spring框架大小只有1MB左右，核心Jar包小，启动的资源小。</li><li><strong>非侵入式</strong><ol><li><code>非侵入式</code>指的是当编写业务代码时，我们并不会去继承Spring特定的类或者去实现Spring已有的接口，这样所编写的业务代码就没有过多依赖于Spring框架，可以更方便实现代码复用与移植。比如Spring框架，通过配置完成依赖注入就可以使用，当我们想换个框架，只需要修改相应的配置，程序仍然可以运行（一般Spring所倡导的无侵入性一般来说都是指它的IOC框架）。</li><li><code>侵入式</code>让用户代码产生对框架的依赖，这些代码不能在框架外使用，不利于代码的复用。</li></ol></li><li><strong>控制反转（IOC）</strong><br>IOC是指将对象的创建和对象生命周期的管理交由Spring来处理，开发人员可以把更多的精力集中于业务的开发上面，而不用关注于对象如何创建、如何管理、对象与对象之间的依赖关系怎么传递（在依赖注入中，对象不再自己创建或查找它们所依赖的对象，而是通过外部机制（配置文件/注解）将依赖项提供给它们）。另外，通过IOC可以促进代码的松耦合。<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1693278010759-deeea515-6b57-4a15-9216-8dedac9ae715.png" alt="传统设计" title="传统设计"><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1693278032871-06eedae8-7a1d-4c54-85f1-3f1b6ac36dd7.jpeg" alt="IOC容器" title="IOC容器"></li><li><strong>面向切面（AOP） </strong><br>面向切面编程指的是在业务开发过程中将与业务无关但又在编写代码过程中会被多次使用的代码块（比如日志、事务等）从业务代码中抽离出来，单独封装，当需要使用时再把其织入到业务代码处。<br>Spring支持面向切面编程，它可以在程序运行期间动态的将某段代码切入到指定方法位置。在Spring中提供了Spring AOP模块，通过定义切面类<code>@Aspect</code>，并在切面类的通知<code>@Before(切点表达式)</code>写入要执行代码逻辑，通过切入点<code>@Pointcut(&quot;execution(* com.remcarpediem.test.aop.service..*(..))&quot;)</code>对连接点进行拦截的条件定义，从而帮助开发人员方便的实现面向切面编程。</li><li><strong>容器</strong><br>Spring包含并管理应用对象的配置和生命周期。Spring可以通过可配置原型(prototype)来配置每个bean如何被创建。另外Spring会负责创建、初始化、维护和销毁应用程序中的对象。</li><li><strong>事务管理</strong><br>Spring中提供了编程式事务管理以及声明式事务管理两种对事务的支持。Spring提供了事务管理的相关接口，通过在类、方法或接口上加<code>@Transactional</code>注解来进行事务管理。</li><li><strong>方便程序测试</strong><br>Spring对Junit支持，可以通过注解方便的测试Spring程序。</li></ol><p>参考：<br><a href="https://www.cnblogs.com/tanghaorong/p/14757368.html" target="_blank" rel="noopener">https://www.cnblogs.com/tanghaorong/p/14757368.html</a><br><a href="https://blog.csdn.net/lsqingfeng/article/details/115503409" target="_blank" rel="noopener">https://blog.csdn.net/lsqingfeng/article/details/115503409</a></p>]]></content>
    
    <summary type="html">
    
      关注于“为什么”
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://xingxin-99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何理解Spring的IOC能降低耦合度？</title>
    <link href="https://xingxin-99.github.io/2023/08/28/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Spring%E7%9A%84IOC%E8%83%BD%E9%99%8D%E4%BD%8E%E8%80%A6%E5%90%88%E5%BA%A6%EF%BC%9F/"/>
    <id>https://xingxin-99.github.io/2023/08/28/如何理解Spring的IOC能降低耦合度？/</id>
    <published>2023-08-28T08:49:25.000Z</published>
    <updated>2023-08-28T08:57:30.585Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>耦合：表示两个子系统（或类）之间的关联程度，当一个子系统（或类）发生变化时对另一个子系统（或类）的影响很小，则称它们是松散耦合的；反之，如果变化的影响很大时，则称它们是紧密耦合的。<br>内聚：一个模块内部只负责一件事情</p></blockquote><ol><li>采用传统方式创建对象<br>如果采用<code>new</code>关键词去创建对象，我们声明了一个<code>折扣劵</code>类，但此时业务改变，要把<code>折扣劵</code>类改成<code>满减劵</code>类，那需要找到代码中的所有<code>折扣劵</code>类去把它换成<code>满减劵</code>类，另外如果<code>折扣劵</code>类有<code>A()</code>方法，而<code>满减劵</code>类没有，那么还需要改动并检查对应的实现方法。并且进行类的替换可能会带来其他的问题，因此每改动一次需要对业务进行测试，以防止出现错误。这种实现方式改动一个类对整体代码的影响很大，体现了对象与代码之间的一个紧耦合的关系。</li><li>面向接口编程<br>为了解决上述的实现方式存在的问题，可以把<code>折扣劵</code>类和<code>满减劵</code>类的共同特性提取出来，设计成为一个接口，这样就防止了在对实现类进行改动之后，出现方法不匹配的问题。这在一定程度上降低了代码的耦合度。但是这种改动方式仍然没有解决要把<code>满减劵</code>替换为<code>折扣劵</code>，仍然需要去找到代码中所有的<code>满减劵</code>来对代码进行改动的这个问题。比如代码里new了100个满减劵对象，就仍然需要找到这100个并把把它替换为折扣劵。另外，当优惠券的类型越来越多时，那么对这些类的管理也将变得困难起来。</li><li><p>工厂模式<br>将优惠券的创建过程交由优惠劵工厂来统一管理，程序员在开发过程中是更关注于得到优惠券对象后如何使用。但是这种方式仍然没有解决要把<code>满减劵</code>替换为<code>折扣劵</code>，需要去找到代码中所有的<code>满减劵</code>来对代码进行改动的这个问题。</p><pre><code class="java">class couponFactory{couponFactory(){}public static Coupon getInstance(String type){ Coupon result = null; if(&quot;discount&quot;.equals(type)){   result = new discount(); } if(&quot;fullMinus&quot;.equals(type)){   result = new fullMinus(); } return result;}}</code></pre></li><li><p>反射<br>将具体调用哪种优惠券类型延时到运行期确定，编译期并不指定要调用的折扣劵的类型。这样如果要修改折扣劵类型，只需修改配置文件即可，不需要再去找到所有的优惠券对象将其名称从折扣劵修改为满减劵。</p><pre><code class="java">CouponFactory.getInstance(配置文件中的优惠券名字); // 请注意我们使用的是第二层的接口coupon.count();</code></pre></li><li><p>IOC<br>IOC的核心就是：工厂模式+反射+读取配置文件。<br>上述的工厂是只能创造优惠券的工厂，但是我们想要一个不管是什么类型的对象都可以生产的工厂，而Spring IOC就提供了这样一个功能。所有的Java Bean对象都交由IOC工厂来管理，如果我们想要创建一个对象，那么我们可以声明该对象，并且加上像@Bean、@Controller、@Service…这些的注解，在启动SpringBoot时，Spring会扫描这些加了注解的类，并对其进行创建和管理。通过这种思想，如果我们想要对项目中的某个对象的类型进行变动，只需要修改配置文件即可，这样就大大降低了代码的耦合度。</p></li></ol><p>参考：</p>]]></content>
    
    <summary type="html">
    
      什么是耦合？如何理解Spring的IOC能降低耦合度？
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
      <category term="IOC" scheme="https://xingxin-99.github.io/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://xingxin-99.github.io/2023/08/27/%E6%B5%8B%E8%AF%95-1/"/>
    <id>https://xingxin-99.github.io/2023/08/27/测试-1/</id>
    <published>2023-08-27T08:18:42.000Z</published>
    <updated>2023-08-27T08:50:26.002Z</updated>
    
    <content type="html"><![CDATA[<style>  table {    width: 100%; /*表格宽度*/    max-width: 65em; /*表格最大宽度，避免表格过宽*/    border: 1px solid #dedede; /*表格外边框设置*/    margin: 15px auto; /*外边距*/    border-collapse: collapse; /*使用单一线条的边框*/    empty-cells: show; /*单元格无内容依旧绘制边框*/  }  table th,  table td {    height: 25px; /*统一每一行的默认高度*/    font-size: 10px;  /*行内字符大小*/    border: 1px solid #dedede; /*内部边框样式*/    padding: 0 10px; /*内边距*/  }    table th {      font-size: 10px;  /*表头字符大小*/      font-weight: bold; /*加粗*/      text-align: center ; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/      background: rgba(158,188,226,0.2); /*背景色*/  }</style><h1 id="测试基础"><a href="#测试基础" class="headerlink" title="测试基础"></a>测试基础</h1><h2 id="什么是软件测试？"><a href="#什么是软件测试？" class="headerlink" title="什么是软件测试？"></a>什么是软件测试？</h2><table><thead><tr><th>复习时间</th><th>2023/8/6</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>使用某些技术手段对软件进行操作，发现软件缺陷，判断软件是否满足使用需求</p><h2 id="什么是黑盒测试？"><a href="#什么是黑盒测试？" class="headerlink" title="什么是黑盒测试？"></a>什么是黑盒测试？</h2><table><thead><tr><th>复习时间</th><th>2023/8/4</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>黑盒测试是指在进行测试时，我们看不见程序的源代码，只对程序的功能进行测试。<br>在测试的过程中主要关注输入与输出以及输出是否符合预期。<br>其中功能测试又可称为黑盒测试</p><h2 id="什么是白盒测试？"><a href="#什么是白盒测试？" class="headerlink" title="什么是白盒测试？"></a>什么是白盒测试？</h2><table><thead><tr><th>复习时间</th><th>2023/8/4</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>白盒测试是指测试的过程中能看到程序的源代码，主要是对程序的源代码进行测试。测试者检查程序的内部结构，根据内部逻辑来设计测试用例。<br>比如单元测试就是一种白盒测试。<br>白盒测试根据软件的内部逻辑设计测试用例，常用的技术是逻辑覆盖，即考察用测试数据运行被测程序时对程序逻辑的覆盖程度。主要的覆盖标准有 6 种：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、组合条件覆盖和路径覆盖。</p><h2 id="什么是灰盒测试？（集成测试、接口测试）"><a href="#什么是灰盒测试？（集成测试、接口测试）" class="headerlink" title="什么是灰盒测试？（集成测试、接口测试）"></a>什么是灰盒测试？（集成测试、接口测试）</h2><table><thead><tr><th>复习时间</th><th>2023/8/4</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>灰盒测试是介于白盒测试和黑盒测试之间的一种测试方法，它能看见程序的部分源码，主要是对程序的接口进行测试。<br>在我们执行测试的过程中，一般是先进行单元测试，再进行集成测试，最后进行系统测试。在我们测试完成单个模块运行正确之后，还需要去验证单个模块与模块组合在一起时是否会出现问题，这个方式就是灰盒测试。 </p><h2 id="为什么进行了白盒测试之后还要进行黑盒测试？"><a href="#为什么进行了白盒测试之后还要进行黑盒测试？" class="headerlink" title="为什么进行了白盒测试之后还要进行黑盒测试？"></a>为什么进行了白盒测试之后还要进行黑盒测试？</h2><table><thead><tr><th>复习时间</th><th>2023/8/4</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>白盒测试不仅仅关注输入与输出的结果是否正确，同时还关注程序是如何处理的。而黑盒测试在整个测试过程中只关注输入和输出，如果输入一个测试数据，输出的结果是正确的，我们就认为这个功能是正确的。虽然从某种角度来看，白盒测试比黑盒测试更为全面。但是有一些黑盒测试的内容是白盒测试不能做到的。比如黑盒测试是更接近于用户使用的测试，因此我们还会关注程序的易用性、界面展示、业务流程等，而白盒测试时并不考虑这些。</p><h2 id="测试的基本流程"><a href="#测试的基本流程" class="headerlink" title="测试的基本流程"></a>测试的基本流程</h2><table><thead><tr><th>复习时间</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><ol><li>需求分析<br>阅读需求文档，联合前端、后端、测试、产品等部门，确保各部门对需求理解一致；了解软件的具体功能</li><li>计划编写<br>确定测试的目标、范围<br>对人力、物力进行分配，确定那些人要具体做哪些事情，对进度进行安排<br>确定要使用哪些测试工具、测试策略</li><li>用例设计<br>分析需求，从需求中提取测试点，来设计测试用例</li><li>用例执行，提交bug，回归测试<br>当进行测试后，会发现软件的缺陷。确定缺陷后，将缺陷提交给开发人员，开发人员修改后进行回归测试</li><li>测试报告</li></ol><h2 id="常见的黑盒测试方法有哪些？"><a href="#常见的黑盒测试方法有哪些？" class="headerlink" title="常见的黑盒测试方法有哪些？"></a>常见的黑盒测试方法有哪些？</h2><table><thead><tr><th>复习时间</th><th>2023/8/4</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><ol><li><strong>等价类划分法（穷举场景）</strong><br>指在所有的测试数据中，对具有某种共同特征的数据集合进行划分，然后从每一个子集中选取<br>少数具有代表性的数据作为测试用例。<br><strong>举例：验证6-10位自然数QQ号的合法性</strong><br>按照等价类划分法：<br>有效等价类：6-10位自然数；无效等价类：&lt;6位，&gt;10位自然数，以及6-10位非自然数</li><li><strong>边界值分析（有边界范围）</strong><br>对输入、输出的边界值进行测试。<br>在边界值分析法中规范了要选择的边界值，上点、离点、内点</li><li><strong>因果图分析</strong><br>利用图解法分析输入的各种组合情况，从而设计测试用例的方法</li><li><strong>判定表法（多条件依赖关系）</strong><br>以表格形式表达多条件依赖逻辑判断的工具<br>判定表由条件桩、动作桩、条件项、动作项组成，根据条件项确定动作项，贯穿条件项和动作项的一列是一条规则<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1691310738780-8fc6a32f-f14a-46ec-b105-2c42ac7f833f.png" alt="image.png"></li><li><strong>错误推测法</strong><br>根据测试者以往测试经验来对可能出现错误的地方进行测试。</li></ol><h2 id="为什么要进行自动化测试？"><a href="#为什么要进行自动化测试？" class="headerlink" title="为什么要进行自动化测试？"></a>为什么要进行自动化测试？</h2><table><thead><tr><th>复习时间</th><th>2023/8/16</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>自动化测试是指使用自动化测试工具来执行测试用例，它把以人为驱动的测试转变为以机器驱动，代替了我们手工执行测试的行为。</p><ol><li>通过采用自动化测试，可以替代大量重复性的工作，提高测试效率</li><li>保证每次测试的一致性和可重复性。由于每次自动化测试执行时脚本都是相同的，所以每次执行的测试具有一致性，同时也可以提高回归测试的效率。</li><li>可以更好的利用非工作时间。由于自动化测试能够哪找计划自动执行，因此就可以利用非工作时间使用自动化测试来执行测试。</li></ol><h2 id="测试用例编写规范"><a href="#测试用例编写规范" class="headerlink" title="测试用例编写规范"></a>测试用例编写规范</h2><table><thead><tr><th>用例编号</th><th>用例标题(预期结果+测试点)</th><th>测试模块/项目</th><th>用例级别</th><th>预置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>login_001</td><td>登陆失败（手机号未注册+非空密码）</td><td>login</td><td>P1</td><td>1.APP应用正常;2.网络正常</td><td>1.打开登录页面;2.输入手机号;3.输入密码;4.点击登录</td><td>手机号：13257894512;密码：1458796</td><td>登陆失败。提示：“手机号未注册”</td></tr></tbody></table><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><table><thead><tr><th>Selenium组件</th><th>介绍</th></tr></thead><tbody><tr><td>Selenium WebDriver</td><td>模拟用户操作浏览器</td></tr><tr><td>Selenium IDE</td><td>提供录制Selenium测试用例</td></tr><tr><td>Selenium Grid</td><td>模拟多个操作系统/浏览器执行测试用例</td></tr></tbody></table><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux如何实时查看日志记录？"><a href="#Linux如何实时查看日志记录？" class="headerlink" title="Linux如何实时查看日志记录？"></a>Linux如何实时查看日志记录？</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>less filename</td><td></td></tr><tr><td>tail notes.log</td><td>默认显示最后 10 行。</td></tr></tbody></table><p>-f 循环读取<br>-c&lt;数目&gt; 显示的字节数<br>-n&lt;行数&gt; 显示文件的尾部 n 行内容 |<br>| tail -f filename | 把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。 |<br>| tail -n +20 notes.log | 显示文件 notes.log 的内容，从第 20 行至文件末尾 |<br>| tail -c 10 notes.log | 显示文件 notes.log 的最后 10 个字符: |</p><h2 id="linux命令，统计一个文本中关键字出现的次数"><a href="#linux命令，统计一个文本中关键字出现的次数" class="headerlink" title="linux命令，统计一个文本中关键字出现的次数"></a>linux命令，统计一个文本中关键字出现的次数</h2><pre><code class="java">grep -o targetStr filename | wc -l</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/1692771696392-1f1e0175-75f4-4e36-88dd-b7998d23db95.png" alt="image.png"></p><h2 id="linux-查找当前目录下所有后缀为-py文件"><a href="#linux-查找当前目录下所有后缀为-py文件" class="headerlink" title="linux 查找当前目录下所有后缀为 .py文件"></a>linux 查找当前目录下所有后缀为 .py文件</h2><pre><code class="java">find ./ -name &quot;*.py&quot;</code></pre><h2 id="linux常用命令：查看指定端口进程"><a href="#linux常用命令：查看指定端口进程" class="headerlink" title="linux常用命令：查看指定端口进程"></a>linux常用命令：查看指定端口进程</h2><pre><code class="java"># 查看某进程端口占用情况ps -ef |grep tomcatps -p PID 查看进程的详细信息</code></pre><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="设计购物车测试用例"><a href="#设计购物车测试用例" class="headerlink" title="设计购物车测试用例"></a>设计购物车测试用例</h2><h2 id="搜索页面设计测试用例"><a href="#搜索页面设计测试用例" class="headerlink" title="搜索页面设计测试用例"></a>搜索页面设计测试用例</h2><h2 id="抢红包设计测试用例"><a href="#抢红包设计测试用例" class="headerlink" title="抢红包设计测试用例"></a>抢红包设计测试用例</h2><h2 id="微信朋友圈测试用例"><a href="#微信朋友圈测试用例" class="headerlink" title="微信朋友圈测试用例"></a>微信朋友圈测试用例</h2><h2 id="支付测试用例"><a href="#支付测试用例" class="headerlink" title="支付测试用例"></a>支付测试用例</h2><h2 id="淘宝搜索框测试用例"><a href="#淘宝搜索框测试用例" class="headerlink" title="淘宝搜索框测试用例"></a>淘宝搜索框测试用例</h2><h1 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h1><h2 id="怎么理解的测开这个岗位"><a href="#怎么理解的测开这个岗位" class="headerlink" title="怎么理解的测开这个岗位"></a>怎么理解的测开这个岗位</h2>]]></content>
    
    <summary type="html">
    
      测试基础八股
    
    </summary>
    
      <category term="测试" scheme="https://xingxin-99.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="https://xingxin-99.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://xingxin-99.github.io/2023/08/26/WebSocket/"/>
    <id>https://xingxin-99.github.io/2023/08/26/WebSocket/</id>
    <published>2023-08-26T10:50:39.000Z</published>
    <updated>2023-08-27T08:19:55.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WbeSocket是一个基于TCP的一种新的<strong>网络协议</strong>（ws协议）（不同于Http协议），是一种<strong>全双工</strong>的通信协议，它即允许浏览器向服务器端推送消息，同时也允许服务器端向浏览器推送消息。浏览器和服务器只需要经历一次握手，就可以创建一个<strong>持久性连接</strong>，并在连接中进行双向数据传输。</p><h2 id="WebSocket和Http有什么不同？"><a href="#WebSocket和Http有什么不同？" class="headerlink" title="WebSocket和Http有什么不同？"></a>WebSocket和Http有什么不同？</h2><p>WebSocket是一种全双工的通信方式，它允许两端都可以主动的向对方推送消息，因此Websocket更像是现实生活中打电话的场景，电话接通后，双方都可以听到对方的信息。而Http它是请求响应模式，由客户端发出请求，浏览器回以响应。</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1690872227077-38fcaa95-6f59-4304-b42a-e2810bb76ba3.png" alt="image.png"></p><h2 id="Websocket的应用场景（页面不刷新，但数据可以实时变化）"><a href="#Websocket的应用场景（页面不刷新，但数据可以实时变化）" class="headerlink" title="Websocket的应用场景（页面不刷新，但数据可以实时变化）"></a>Websocket的应用场景（页面不刷新，但数据可以实时变化）</h2><p>视频弹幕、网页聊天（通过Websocket把聊天消息推送到页面中显示）、体育实况更新、股票基金报价实时更新</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1690871933655-8ae729f7-b16c-4a8c-a763-752cbab4137a.png" alt="image.png"></p><h2 id="WebSocket的原理是什么？"><a href="#WebSocket的原理是什么？" class="headerlink" title="WebSocket的原理是什么？"></a>WebSocket的原理是什么？</h2><p>客户端向服务器发送建立连接的请求，此时发送的请求信息如下：</p><pre><code class="java">GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com</code></pre><p><strong>Upgrade: </strong>在 HTTP 请求中，Upgrade 头部字段通知服务器客户端希望升级到其他协议。它指示服务器在响应中是否支持升级，并将协议更改为请求中指定的协议。<br><strong>Connection: Upgrade :</strong> 在 HTTP 请求中，Connection 头部字段指示客户端是否希望与服务器建立持久连接。而当与 Upgrade 头部一同使用时，Connection: Upgrade 表示客户端希望升级到其他协议，并要求服务器在响应中进行协议升级。<br>在服务器的响应中，如果支持升级到 WebSocket，会包含如下的响应头部：</p><pre><code class="java">HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code></pre><p>这样，客户端和服务器之间的连接就会从普通的 HTTP 连接升级为 WebSocket 连接，后续通信将使用 WebSocket 协议。</p><h2 id="在WeSocket之前是如何进行实时通信的？"><a href="#在WeSocket之前是如何进行实时通信的？" class="headerlink" title="在WeSocket之前是如何进行实时通信的？"></a>在WeSocket之前是如何进行实时通信的？</h2><ol><li><strong>轮询。</strong>客户端定期向服务器发送请求，判断服务器中是否有新的数据可用。<br>拿来单提醒这个功能举例，如果不使用WebSocket，就需要客户端向服务端轮询的发起查询请求，判断数据库中是否存在新的还未进行来单提醒订单数据，如果存在的话，则将来单提醒需要的信息返回给前端。<br><strong>缺点：</strong>会在客户端与服务器之间产生大量的请求与响应，导致不必要的网络开销和延迟。</li><li><strong>长轮询。</strong>客户端发出请求后，保持连接打开，等待新数据响应后在关闭连接。<br><strong>优缺点：</strong>解决了无效轮询的数量，但仍然需要频繁建立和关闭连接。</li><li><strong>Comet。</strong>模拟实时通信，在返回请求后继续保持连接打开。核心思想是保持长连接来实现实时通信，并允许服务器通过流式传输等推送技术来主动向客户端推送消息。<br><strong>缺点： </strong>该方法依然依赖于无状态的HTTP连接，其要求服务器端有特殊的功能(类似于流式传输等推送技术)来临时挂起连接。  </li></ol><h2 id="WebSocket的优势"><a href="#WebSocket的优势" class="headerlink" title="WebSocket的优势"></a>WebSocket的优势</h2><ol><li><strong>双向实时通信。</strong>在单个、长时间的连接上进行双向实时通信。在需要快速实时更新的应用程序里，比HTTP更高效。</li><li><strong>降低延迟。</strong>数据可用在客户端与服务器之间以比HTTP更低的延迟进行传输。（头部相对较小；在长连接里传输数据，不必在每次建立连接）</li><li><strong>更高效的资源利用。</strong>由于连接只建立了一次，因此减少了重复请求和响应的开销</li></ol><h2 id="WebSocket的限制"><a href="#WebSocket的限制" class="headerlink" title="WebSocket的限制"></a>WebSocket的限制</h2><ol><li>不提供加密功能。如果传输的数据要保证安全性，需采用像SSL这样的协议</li><li>不支持古老浏览器。</li><li>保持长连接需要服务器不断维护和处理连接的状态。</li></ol><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>使用websocket.html页面作为WebSocket客户端（由客户端向服务端发送握手请求，服务端响应后，二者就建立了持久连接）</li><li>导入WebSocket的maven坐标</li><li>导入WebSocket服务端组件WebSocketServer（接收客户端发来的请求并处理，类似于Controller），用于和客户端通信</li><li>导入配置类WebSocketConfiguration，注册WebSocket的服务端组件</li><li>导入定时任务类WebSocketTask，定时向客户端推送数据（用于测试，可有可无）</li></ol><table><thead><tr><th>函数/注解</th><th>作用</th></tr></thead><tbody><tr><td>new WebSocket(url)</td><td>向地址为url的服务端建立连接，并返回ws对象，里面提供了连接相关的API</td></tr><tr><td>@ServerEndpoint(“/ws/{sid}”)</td><td>将目前的类定义成一个websocket服务器端, 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</td></tr><tr><td>@OnOpen</td><td>连接建立成功调用方法</td></tr><tr><td>@OnMessage</td><td>收到客户端消息后调用方法</td></tr></tbody></table><h3 id="WebSocket组件"><a href="#WebSocket组件" class="headerlink" title="WebSocket组件"></a><strong>WebSocket组件</strong></h3><pre><code class="java">package com.sky.websocket;import org.springframework.stereotype.Component;import javax.websocket.OnClose;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.util.Collection;import java.util.HashMap;import java.util.Map;/** * WebSocket服务 */@Component//标识该类为WebSokcet服务器端，监听该URL地址，客户端可通过该URL连接到该服务器端@ServerEndpoint(&quot;/ws/{sid}&quot;)public class WebSocketServer {    //存放会话对象    //一个Session就是一个会话，当客户端与服务端建立连接后，就会生成一个session会话    private static Map&lt;String, Session&gt; sessionMap = new HashMap();    /**     * 连接建立成功调用的方法     * sid为客户端的标识，连接建立成功则把该会话存入到map中     */    @OnOpen    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) {        System.out.println(&quot;客户端：&quot; + sid + &quot;建立连接&quot;);        sessionMap.put(sid, session);    }    /**     * 收到客户端消息后调用的方法     *     * @param message 客户端发送过来的消息     */    @OnMessage    public void onMessage(String message, @PathParam(&quot;sid&quot;) String sid) {        System.out.println(&quot;收到来自客户端：&quot; + sid + &quot;的信息:&quot; + message);    }    /**     * 连接关闭调用的方法     *     * @param sid     */    @OnClose    public void onClose(@PathParam(&quot;sid&quot;) String sid) {        System.out.println(&quot;连接断开:&quot; + sid);        sessionMap.remove(sid);    }    /**     * 群发     *     * @param message     */    public void sendToAllClient(String message) {        Collection&lt;Session&gt; sessions = sessionMap.values();        for (Session session : sessions) {            try {                //服务器向客户端发送消息                session.getBasicRemote().sendText(message);            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p><strong>定义配置类，注册WebSocket的服务端组件</strong></p><pre><code class="java">package com.sky.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;/** * WebSocket配置类，用于注册WebSocket的Bean */@Configurationpublic class WebSocketConfiguration {    @Bean    public ServerEndpointExporter serverEndpointExporter() {        return new ServerEndpointExporter();    }}</code></pre><h2 id="来单提醒功能实现"><a href="#来单提醒功能实现" class="headerlink" title="来单提醒功能实现"></a>来单提醒功能实现</h2><ol><li><p>通过WebSocket来实现管理端页面和服务端保持长连接<br><strong>服务端：</strong>引入WebSocket依赖，注册WebSokcet组件，监听Websocket客户端发送的建立连接消息<strong>浏览器：</strong>在前端页面中已经写好了WebSocket相关的js代码，登录成功后，页面解析js代码，向服务端发送建立连接的请求，服务端收到请求后响应消息，客户端和服务端的长连接建立成功，之后双方便可通过该连接推送消息<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1690875135416-180d3208-9438-42c2-a697-5046a90bfdd6.png" alt="image.png"></p></li><li><p>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息<br>当客户支付成功后，微信端会调用我们写好的一个回调方法paySuccess()来执行支付成功后的处理逻辑，因此我们在该回调函数的逻辑中补充了由服务器端向客户端推送消息的代码。<br><strong>主要逻辑：</strong>注入WebSocketServer对象，生成我们要发送到客户端的JSON消息，调用写好的向客户端推送消息的API（浏览器端与服务器端建立长连接后生成一个session对象，通过这个session对象向客户端发送消息），将该消息推送到客户端页面</p></li></ol><pre><code class="java">@Autowiredprivate WebSocketServer webSocketServer;/** * 支付成功，修改订单状态 * * @param outTradeNo */public void paySuccess(String outTradeNo) {    // 当前登录用户id    Long userId = BaseContext.getCurrentId();    // 根据订单号查询当前用户的订单    Orders ordersDB = orderMapper.getByNumberAndUserId(outTradeNo, userId);    // 根据订单id更新订单的状态、支付方式、支付状态、结账时间    Orders orders = Orders.builder()            .id(ordersDB.getId())            .status(Orders.TO_BE_CONFIRMED)            .payStatus(Orders.PAID)            .checkoutTime(LocalDateTime.now())            .build();    orderMapper.update(orders);    //////////////////////////////////////////////    Map map = new HashMap();    map.put(&quot;type&quot;, 1);//消息类型，1表示来单提醒    map.put(&quot;orderId&quot;, orders.getId());    map.put(&quot;content&quot;, &quot;订单号：&quot; + outTradeNo);    //通过WebSocket实现来单提醒，向客户端浏览器推送消息    webSocketServer.sendToAllClient(JSON.toJSONString(map));    ///////////////////////////////////////////////////}</code></pre><pre><code class="java">/** * 群发 * * @param message */public void sendToAllClient(String message) {    Collection&lt;Session&gt; sessions = sessionMap.values();    for (Session session : sessions) {        try {            //服务器向客户端发送消息            session.getBasicRemote().sendText(message);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><ol start="3"><li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报（前端页面已实现）</li><li>约定服务端发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ol><li>type 为消息类型，1为来单提醒 2为客户催单</li><li>orderId 为订单id</li><li>content 为消息内容</li></ol></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7020964728386093093#heading-4" target="_blank" rel="noopener">一文吃透 WebSocket 原理 刚面试完，趁热赶紧整理 - 掘金</a><br><a href="https://www.bilibili.com/video/BV1ac411c7vr/?spm_id_from=333.337.search-card.all.click&amp;vd_source=028fc5fb3f265ee4a69cb86472cc5bba" target="_blank" rel="noopener">10 分钟 理论 + 实操 搞懂 WebSocket_哔哩哔哩_bilibili</a></p>]]></content>
    
    <summary type="html">
    
      WebSocket的原理？为什么要使用WebSokcet？在使用WebSocket之前是如何进行实时通信的？
    
    </summary>
    
      <category term="项目" scheme="https://xingxin-99.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="WebSocket" scheme="https://xingxin-99.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>JWT安全认证</title>
    <link href="https://xingxin-99.github.io/2023/08/26/JWT%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/"/>
    <id>https://xingxin-99.github.io/2023/08/26/JWT安全认证/</id>
    <published>2023-08-26T10:50:12.000Z</published>
    <updated>2023-08-26T10:57:05.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JWT安全认证"><a href="#JWT安全认证" class="headerlink" title="JWT安全认证"></a>JWT安全认证</h1><p>JWT的全称为Json Web Tocken，它通过数字签名的方式，以Json对象为载体，实现在客户端和服务器之间安全的传输数据。JWT由三部分组成，这三部分分别是Header、Payload、Signature，这三部分之间用.拼接。<br>当用户第一次登录后，生成JWT，并将其以tocken返回给前端。后续客户端每次发起的请求都包含JWT。系统在处理请求之前，会先使用拦截器拦截请求，对请求中的JWT进行安全校验，通过之后才放行<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1690885408290-547a9b12-a012-48bd-a46a-6830d725d5ad.png" alt="image.png"></p><h2 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h2><ol><li>Header由两部分组成：token的类型以及签名算法的名称。</li></ol><pre><code class="java">{    &#39;alg&#39;: &quot;HS256&quot;,    &#39;typ&#39;: &quot;JWT&quot;}</code></pre><p>用Base64对这个JSON编码就得到JWT的第一部分</p><ol start="2"><li>Payload(负载)：在负载中可以声明一些用于传输的数据，比如用户名等信息</li></ol><pre><code class="java">{    &quot;sub&quot;: &#39;1234567890&#39;,    &quot;name&quot;: &#39;john&#39;,    &quot;admin&quot;:true}</code></pre><ol start="3"><li>Signature：对head和payload按照指定的签名算法进行签名，保证JWT没有被篡改过</li></ol><pre><code class="java">var encodedString = base64UrlEncode(header) +&#39;.&#39;+ base64UrlEncode(payLoad);var signature = HMACSHA256(encodedString,&#39;secret&#39;);</code></pre><blockquote><p>如何能确保JWT没有被篡改过？</p></blockquote><ul><li>首先，JWT由头部、负载、签名三部分组成，头部包含了tocken类型以及使用的签名算法，而负载中有我们所声明的JSON型的数据信息，而签名是对头部和负载进行base64编码后，通过签名算法以及服务器端生成的秘钥对base64编码后的头部和负载进行签名。如果有人对头部和负载内容解码之后再生成新的JWT，由于它不知道服务器端秘钥，因此服务器端进行JWT校验失败，就判断此JWT已经被篡改。</li></ul><p>参考：<br><a href="https://blog.csdn.net/Top_L398/article/details/109361680" target="_blank" rel="noopener">JWT详细教程与使用<em>jwt教程</em>一支有理想的月月鸟的博客-CSDN博客</a></p><h2 id="在项目中如何实现JWT安全认证的？"><a href="#在项目中如何实现JWT安全认证的？" class="headerlink" title="在项目中如何实现JWT安全认证的？"></a>在项目中如何实现JWT安全认证的？</h2><ol><li>引入JWT的相关依赖</li><li>通过<code>Jwts.builder</code>去创建一个jwt，通过<code>setClaims</code>方法设置私有声明，私有声明就是我们想在服务器与客户端传送的数据，通过<code>signWith</code>方法设置签名使用的签名算法及签名秘钥，通过<code>setExpiration</code>方法设置签名过期时间，通过<code>compact</code>方法将这些信息组合，生成JWT</li></ol><pre><code class="java">public class JwtUtil {    /**     * 生成jwt     * 使用Hs256算法, 私匙使用固定秘钥     *     * @param secretKey jwt秘钥     * @param ttlMillis jwt过期时间(毫秒)     * @param claims    设置的信息     * @return     */    public static String createJWT(String secretKey, long ttlMillis, Map&lt;String, Object&gt; claims) {        // 指定签名的时候使用的签名算法，也就是header那部分        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;        // 生成JWT的时间        long expMillis = System.currentTimeMillis() + ttlMillis;        Date exp = new Date(expMillis);        // 设置jwt的body        JwtBuilder builder = Jwts.builder()                // 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的                .setClaims(claims)                // 设置签名使用的签名算法和签名使用的秘钥                .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))                // 设置过期时间                .setExpiration(exp);        return builder.compact();    }    /**     * Token解密     *     * @param secretKey jwt秘钥 此秘钥一定要保留好在服务端, 不能暴露出去, 否则sign就可以被伪造, 如果对接多个客户端建议改造成多个     * @param token     加密后的token     * @return     */    public static Claims parseJWT(String secretKey, String token) {        // 得到DefaultJwtParser        Claims claims = Jwts.parser()                // 设置签名的秘钥                .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))                // 设置需要解析的jwt                .parseClaimsJws(token).getBody();        return claims;    }}</code></pre><ol start="3"><li>后端将tocken传递到前端，那么之后每次发送请求时，请求的header中都携带该tocken信息。当前端发起请求时，首先会在拦截器中拦截该请求，并从请求头中获取该tocken进行JWT校验，校验失败则返回“用户未登录”的信息。校验成功则放行，继续接下来的处理逻辑。</li></ol><pre><code class="java">/** * jwt令牌校验的拦截器 */@Component@Slf4jpublic class JwtTokenAdminInterceptor implements HandlerInterceptor {    @Autowired    private JwtProperties jwtProperties;    /**     * 校验jwt     *     * @param request     * @param response     * @param handler     * @return     * @throws Exception     */    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //判断当前拦截到的是Controller的方法还是其他资源        if (!(handler instanceof HandlerMethod)) {            //当前拦截到的不是动态方法，直接放行            return true;        }        //1、从请求头中获取令牌        String token = request.getHeader(jwtProperties.getAdminTokenName());        //2、校验令牌        try {            log.info(&quot;jwt校验:{}&quot;, token);            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());            /////将用户id存储到ThreadLocal////////            BaseContext.setCurrentId(empId);            ////////////////////////////////////            log.info(&quot;当前员工id：&quot;, empId);            //3、通过，放行            return true;        } catch (Exception ex) {            //4、不通过，响应401状态码            response.setStatus(401);            return false;        }    }}</code></pre><pre><code class="java">sky:  jwt:    # 设置jwt签名加密时使用的秘钥    admin-secret-key: itcast    # 设置jwt过期时间    admin-ttl: 7200000    # 设置前端传递过来的令牌名称    admin-token-name: token    user-secret-key: itheima    user-ttl: 7200000    user-token-name: authentication</code></pre><pre><code class="java">@Component@ConfigurationProperties(prefix = &quot;sky.jwt&quot;)@Datapublic class JwtProperties {    /**     * 管理端员工生成jwt令牌相关配置     */    private String adminSecretKey;    private long adminTtl;    private String adminTokenName;    /**     * 用户端微信用户生成jwt令牌相关配置     */    private String userSecretKey;    private long userTtl;    private String userTokenName;}</code></pre><h2 id="cookie、session、token的区别"><a href="#cookie、session、token的区别" class="headerlink" title="cookie、session、token的区别"></a>cookie、session、token的区别</h2><p>由于Http是无状态协议，因此对于服务器来说，它接收到的每个请求都是独立的请求，服务器并不会去记录每个请求之间的联系。但是对于更多的使用场景，我们需要去让服务器记录此次发来的请求是哪个客户端发送来的，比如用户登录进某个网站之后，那么接下来的请求，用户就不需要每次在重复登录，进行身份验证。而通过cookie、session、token我们就能够让服务器端识别发起请求的客户端。</p><ol><li>cookie它是存储在浏览器中的，并且cookie的大小有限制，一般不超过4KB。由于cookie存储在客户端的，因此一般认为cookie不够安全，别人可以直接对本地的cookie进行分析。当浏览器向服务器端发送请求时，那么服务器端首先会判断是否已经为发出该请求的客户端创建了对应的session，如果没有的话，则创建session，并在响应头中设置set-cookie，set-cookie中包含了生成的sessionId。浏览器接收到该响应后，浏览器在下次请求头中自动携带cookie。服务器端接收到请求之后先验证cookie信息，比如验证cookie中的session信息是否存在，存在则正常响应，不存在则拦截返回错误信息。</li><li>session它是存储在服务器端的一个对象，它的大小没有限制，由于是存储在服务器端，因此一般认为session中存储的数据是安全的。当客户端与服务器端建立连接后，它会在服务器端生成一个具有唯一sessionId的session。我们可以把用户的id信息存储到session中，当下次客户端发送请求时，通过判断该session中是否存在用户信息来判断用户的登录状态。但是session也有一些缺点，由于session它是保存在内存中的，因此当有很多客户端和服务器端建立连接时，那么就会在服务器端创建很多session，这样就占用了服务器的内存资源。另外session它并不适用于分布式的环境，比如当有两个tomcat服务器时，采用轮询方式访问服务器，那么用户就要进行多次登录。</li><li>tocken本质上我们可以把它看做一个加密后的字符串，它是由服务器生成，然后相应给客户端，客户端接收之后把它存储到localstorage等地方，之后客户端每次发送请求都会在请求头中携带tocken信息。tokcen</li></ol>]]></content>
    
    <summary type="html">
    
      是如何通过JWT实现安全认证的？原理是什么？
    
    </summary>
    
      <category term="项目" scheme="https://xingxin-99.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="JWT" scheme="https://xingxin-99.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://xingxin-99.github.io/2023/08/25/%E6%B5%8B%E8%AF%95/"/>
    <id>https://xingxin-99.github.io/2023/08/25/测试/</id>
    <published>2023-08-25T05:52:19.000Z</published>
    <updated>2023-08-25T07:15:16.994Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="测试" scheme="https://xingxin-99.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="https://xingxin-99.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>项目</title>
    <link href="https://xingxin-99.github.io/2023/08/25/%E9%A1%B9%E7%9B%AE/"/>
    <id>https://xingxin-99.github.io/2023/08/25/项目/</id>
    <published>2023-08-25T05:51:45.000Z</published>
    <updated>2023-08-25T07:15:12.645Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="项目" scheme="https://xingxin-99.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="https://xingxin-99.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://xingxin-99.github.io/2023/08/25/MySQL/"/>
    <id>https://xingxin-99.github.io/2023/08/25/MySQL/</id>
    <published>2023-08-25T05:50:48.000Z</published>
    <updated>2023-08-25T07:15:46.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL" scheme="https://xingxin-99.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://xingxin-99.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://xingxin-99.github.io/2023/08/25/Redis/"/>
    <id>https://xingxin-99.github.io/2023/08/25/Redis/</id>
    <published>2023-08-25T05:50:30.000Z</published>
    <updated>2023-08-25T07:22:28.702Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="https://xingxin-99.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
