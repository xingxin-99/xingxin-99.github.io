<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Star</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xingxin-99.github.io/"/>
  <updated>2023-08-25T08:25:18.986Z</updated>
  <id>https://xingxin-99.github.io/</id>
  
  <author>
    <name>Star</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://xingxin-99.github.io/2023/08/25/Mybatis/"/>
    <id>https://xingxin-99.github.io/2023/08/25/Mybatis/</id>
    <published>2023-08-25T08:18:45.000Z</published>
    <updated>2023-08-25T08:25:18.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Mybatis概述"><a href="#一、Mybatis概述" class="headerlink" title="一、Mybatis概述"></a>一、Mybatis概述</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680487655144-40ceb047-3022-4026-bbf3-cda45164060f.jpeg" alt><br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680437065377-d99edf14-e83c-486a-88e0-9bdb41372a58.png" alt="image.png"></p><h1 id="二、Mybatis入门程序"><a href="#二、Mybatis入门程序" class="headerlink" title="二、Mybatis入门程序"></a>二、Mybatis入门程序</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680500855072-ee792ea4-2e94-4dc3-b7b8-5a44922f5a7f.jpeg" alt><br>maven中为什么放在resource目录下的资源，等于放在类的根路径下在 Maven 项目中，src/main/resources 目录下的资源文件会被打包进生成的 Jar 或 War 包中，并放在类路径的根目录下。这是因为 Maven 在构建项目时会把 src/main/resources 目录作为类路径的一部分，所以所有放在这个目录下的文件都会被打包进去。<br>在 Java 项目中，类路径指的是 JVM 用来搜索类和资源文件的路径。类路径的根目录是指能够直接被 JVM 搜索到的目录，这个目录下的文件都可以直接用 ClassLoader 加载。在 Maven 项目中，src/main/resources 目录中的文件就是放在这个根目录下的。<br>因此，如果我们把某个资源文件放在 src/main/resources 目录下，它就相当于放在了类路径的根目录下，可以直接通过 ClassLoader 加载，无需指定路径。这也是 Maven 中推荐的一种资源文件的组织方式，方便我们在项目中访问和使用这些文件。</p><pre><code class="java">public class mybatisTest {    public static void main(String[] args) {        SqlSession sqlSession=null;        try {            SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();            InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);            SqlSessionFactory sqlSessionFactory =  sqlSessionFactoryBuilder.build(is);            sqlSession  =sqlSessionFactory.openSession();            int count = sqlSession.insert(&quot;car_insert&quot;);            System.out.println(count);            sqlSession.commit();        } catch (IOException e) {            if(sqlSession!=null){                sqlSession.rollback();            }            throw new RuntimeException(e);        }finally {            if(sqlSession!=null){                sqlSession.close();            }        }    }}</code></pre><h2 id="Junit介绍"><a href="#Junit介绍" class="headerlink" title="Junit介绍"></a>Junit介绍</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680506335553-68c40a50-1f3c-4b52-ad95-a8a6ad5a19d3.jpeg" alt></p><pre><code class="java">public class MathService{    public int sum(int a, int b){        return a+b;    }}</code></pre><pre><code class="java">public class MathServiceTest{    MathService mathService = new MathService();    @Test    public void Testsum(){        int actual =  mathService.sum(1,2);        int expected = 3;        Assert.assertEquals(expected,actual);    }}</code></pre><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680506472504-c1acdd8c-c4b7-4411-aca6-655fb1f9153d.jpeg" alt></p><pre><code class="xml">&lt;settings&gt;  &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;&lt;/settings&gt;</code></pre><h2 id="Mybatis工具类"><a href="#Mybatis工具类" class="headerlink" title="Mybatis工具类"></a>Mybatis工具类</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680508228437-3158357f-aeb1-4a2b-abd1-80e25eea0d32.jpeg" alt></p><pre><code class="java">public class mybatisUtil {    private mybatisUtil(){    }    private static SqlSessionFactory sqlSessionFactory;    static {        try {            SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();            sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));        } catch (IOException e) {            throw new RuntimeException(e);        }    }    public static SqlSession openSession(){        return sqlSessionFactory.openSession();    }}</code></pre><h1 id="三、使用Mybatis完成CRUD"><a href="#三、使用Mybatis完成CRUD" class="headerlink" title="三、使用Mybatis完成CRUD"></a>三、使用Mybatis完成CRUD</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680517974389-0d8347e0-c9a4-413b-a0f3-84d0c88aed54.jpeg" alt></p><pre><code class="xml">&lt;mapper namespace=&quot;com.star.mybatis&quot;&gt;  &lt;insert id=&quot;car_insert&quot;&gt;    insert into t_car(id,car_num,brand,guide_price,produce_time,car_type)    values (null,#{carNum},#{brand},#{guidePrice},#{produceTime},#{carType})  &lt;/insert&gt;  &lt;delete id=&quot;car_delete&quot;&gt;    delete from t_car where id=#{i}  &lt;/delete&gt;  &lt;select id=&quot;car_select&quot; resultType=&quot;com.star.mybatis.introduction.pojo.Car&quot;&gt;    select * from t_car where id=#{id}  &lt;/select&gt;  &lt;select id=&quot;car_selectall&quot; resultType=&quot;com.star.mybatis.introduction.pojo.Car&quot;&gt;    select * from t_car  &lt;/select&gt;&lt;/mapper&gt;</code></pre><pre><code class="java">public class mybatisTest {    @Test    public void deletetest(){        SqlSession sqlSession = mybatisUtil.openSession();        int count = sqlSession.delete(&quot;car_delete&quot;,6);        System.out.println(count);        sqlSession.commit();        sqlSession.close();    }    @Test    public void testInsert(){        Car car = new Car(null,&quot;001&quot;,&quot;长安&quot;,325.00,&quot;2023-04-03&quot;,&quot;燃油&quot;);        SqlSession sqlSession = mybatisUtil.openSession();        int count = sqlSession.insert(&quot;car_insert&quot;,car);        System.out.println(count);        sqlSession.commit();        sqlSession.close();    }    @Test    public void testSelect(){        SqlSession sqlSession = mybatisUtil.openSession();        Car car = sqlSession.selectOne(&quot;car_select&quot;,8);        System.out.println(car);    }    @Test    public void testSelectAll(){        SqlSession sqlSession = mybatisUtil.openSession();        List&lt;Car&gt; cars = sqlSession.selectList(&quot;car_selectall&quot;);        cars.forEach(car -&gt; System.out.println(car));    }}</code></pre><h1 id="四、Mybatis核心配置文件详解"><a href="#四、Mybatis核心配置文件详解" class="headerlink" title="四、Mybatis核心配置文件详解"></a>四、Mybatis核心配置文件详解</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680523257682-8a2d4943-5ab5-4994-8f0b-b8c3234c84ae.jpeg" alt><br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680522258950-c634a153-003f-4159-8076-ff0808bec404.png" alt="image.png"></p><h1 id="五、在WEB中应用Mybatis"><a href="#五、在WEB中应用Mybatis" class="headerlink" title="五、在WEB中应用Mybatis"></a>五、在WEB中应用Mybatis</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680612788721-fc4c90df-db3e-40a4-ab04-e8f0c7560300.jpeg" alt><br>方法作用域方法作用域是指变量、常量和对象在方法中的可见性和生命周期。在方法内部声明的变量和常量只在方法内部可见，当方法执行结束时，它们也随之消失。对象的作用域可以超出方法，例如一个方法返回一个对象，这个对象在方法外部也可以被使用，直到它被垃圾回收器回收。方法作用域的一个重要特点是，方法内部的变量名或参数名可以与类的成员变量名或参数名相同，但是方法内部的变量或参数会覆盖类的成员变量或参数，直到方法执行结束。<br>应用作用域应用作用域是指对象的生命周期与应用程序的生命周期相同，即在应用程序启动时创建，在应用程序关闭时销毁。在Spring框架中，应用作用域的对象通常使用单例模式创建。在应用作用域下创建的对象可以在整个应用程序中共享，因此在多个地方使用同一个对象可以提高程序的性能。例如，在Web应用程序中，可以在应用作用域下创建一个共享的数据源对象，以便多个线程共享这个对象，避免了频繁创建和销毁数据源对象的开销。<br>请求作用域请求作用域是指在一次 HTTP 请求的处理过程中所创建的对象的作用域。它的生命周期是从请求的开始到响应的结束。在一个 HTTP 请求中，通过 <strong>HttpServletRequest</strong> 对象可以获取请求作用域，可以将对象存放在请求作用域中，然后在整个请求处理过程中共享这些对象。通常情况下，请求作用域可以用于在不同的页面之间传递数据。<br>为什么SqlSessionFactory的作用域为应用作用域MyBatis中的<strong>SqlSessionFactory</strong>是一个重量级的对象，主要负责创建和管理<strong>SqlSession</strong>，其创建过程包含了加载配置文件、解析映射文件、创建数据库连接等操作，因此在创建<strong>SqlSessionFactory</strong>对象时会耗费较多的资源和时间。而且，一个<strong>SqlSessionFactory</strong>对象一般情况下只需要创建一次，并在应用生命周期内持续使用，因此将其作用域设置为应用作用域是比较合适的。<br>如果将<strong>SqlSessionFactory</strong>的作用域设置为方法或请求作用域，那么每次执行操作都需要重新创建和销毁<strong>SqlSessionFactory</strong>对象，会导致不必要的资源浪费和性能下降。而将其作用域设置为会话作用域也不太合适，因为<strong>SqlSessionFactory</strong>是线程安全的，多个线程可以共享同一个<strong>SqlSessionFactory</strong>对象，因此在会话作用域中可能会造成不必要的资源浪费和线程安全问题。<br>为什么SqlSession的作用域为请求作用域在使用 MyBatis 进行数据库操作时，每个 SqlSession 都代表了一次对数据库的操作会话。通常情况下，一个请求需要操作数据库多次，因此需要多次创建 SqlSession 对象。由于 SqlSession 是非线程安全的，每次创建一个 SqlSession 对象实例既需要时间又占用内存，所以为了更好地控制资源的开销，将 SqlSession 的作用域设置为请求作用域是比较合适的选择。<br>将 SqlSession 的作用域设置为请求作用域可以保证每个请求都能获取到一个独立的 SqlSession 实例，避免了线程安全问题和并发访问的冲突。同时，由于每个 SqlSession 对象实例只存在于请求过程中，不会长时间占用内存，能够有效地避免内存泄露的问题，提升了应用程序的稳定性和性能。</p><h1 id="六、使用javassist生成类"><a href="#六、使用javassist生成类" class="headerlink" title="六、使用javassist生成类"></a>六、使用javassist生成类</h1><h1 id="七、MyBatis中接口代理机制及使用"><a href="#七、MyBatis中接口代理机制及使用" class="headerlink" title="七、MyBatis中接口代理机制及使用"></a>七、MyBatis中接口代理机制及使用</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680779380963-dd2fa5fd-6722-4740-87a9-5e51f9ac3d37.jpeg" alt></p><h1 id="八、Mybatis的小技巧"><a href="#八、Mybatis的小技巧" class="headerlink" title="八、Mybatis的小技巧"></a>八、Mybatis的小技巧</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1680852662243-4d469fdc-96b1-48be-9108-4dccb512a3bd.jpeg" alt></p><h1 id="九、Mybatis参数处理"><a href="#九、Mybatis参数处理" class="headerlink" title="九、Mybatis参数处理"></a>九、Mybatis参数处理</h1><h1 id="十、Mybatis查询语句专题"><a href="#十、Mybatis查询语句专题" class="headerlink" title="十、Mybatis查询语句专题"></a>十、Mybatis查询语句专题</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681024141004-771be03d-37b8-4b01-bd6f-af9f435b370f.jpeg" alt></p><h1 id="十一、动态SQL"><a href="#十一、动态SQL" class="headerlink" title="十一、动态SQL"></a>十一、动态SQL</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681115128363-72f3157f-9b9d-43e8-a88d-593267156068.jpeg" alt></p><h1 id="十一、Mybatis高级映射及延迟加载"><a href="#十一、Mybatis高级映射及延迟加载" class="headerlink" title="十一、Mybatis高级映射及延迟加载"></a>十一、Mybatis高级映射及延迟加载</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681130838712-10994ee4-d61e-4114-b77d-47f42a16195f.jpeg" alt></p><h1 id="十二、Mybatis缓存"><a href="#十二、Mybatis缓存" class="headerlink" title="十二、Mybatis缓存"></a>十二、Mybatis缓存</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681197006556-164a5e9b-2298-4ee5-8507-0dae4f5f7172.png" alt="image.png"><br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681197647797-ccea69f2-0e10-48e0-98fe-2327e47f459f.png" alt="image.png"></p><h1 id="十三、Mybatis逆向工程"><a href="#十三、Mybatis逆向工程" class="headerlink" title="十三、Mybatis逆向工程"></a>十三、Mybatis逆向工程</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681214819064-04b2f22b-a4e2-443d-9e99-ef4a701de267.jpeg" alt></p><h1 id="十四、Mybatis分页插件"><a href="#十四、Mybatis分页插件" class="headerlink" title="十四、Mybatis分页插件"></a>十四、Mybatis分页插件</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681216603928-190603d7-c9f4-45a9-a951-fe3428581d4f.jpeg" alt><br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681215434369-8709d737-e76d-47f5-9ebd-2bc8635bbce5.png" alt="image.png"></p><h1 id="十五、Mybatis注解式开发"><a href="#十五、Mybatis注解式开发" class="headerlink" title="十五、Mybatis注解式开发"></a>十五、Mybatis注解式开发</h1><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/img/1681217449018-8d6562c0-2059-4762-bdd9-34ad6bd16d9e.jpeg" alt></p><h1 id="十六、Mybatis面试问题"><a href="#十六、Mybatis面试问题" class="headerlink" title="十六、Mybatis面试问题"></a>十六、Mybatis面试问题</h1><p>Mybatis中的动态SQLMybatis中的动态SQL是指可以根据实际情况生成不同SQL语句的一种特殊语法。通常情况下，动态SQL是用来构建复杂的SQL语句的，例如根据不同条件拼接where语句、根据传入的参数构建不同的查询条件等。Mybatis中提供了一些内置的动态SQL语句，例如if、choose、when、otherwise等，可以根据需要自由组合使用，从而构建出灵活多变的SQL语句。同时，Mybatis也支持使用OGNL表达式来处理动态SQL，可以实现更加灵活的条件组合。掌握动态SQL的使用，可以帮助开发者更加方便地构建出灵活、高效的数据访问逻辑，提升应用的性能和扩展性。<br>Mybatis中的一对多映射在 Mybatis 中，一对多映射是指一个实体类中包含一个集合属性，该集合属性中包含多个与另一个实体类的对应关系，即一个实体类与另一个实体类是一对多的关系。例如，一个班级实体类包含多个学生实体类，那么班级实体类就是一的一方，学生实体类就是多的一方。<br>在 Mybatis 中实现一对多映射，需要使用 Mybatis 提供的 association 和 collection 标签。association 标签用于定义单个对象之间的关系，而 collection 标签则用于定义集合对象之间的关系。<br>具体来说，在映射文件中，需要先定义一的一方的查询语句，并使用 association 标签将多的一方的查询结果映射到一的一方中。然后，再定义多的一方的查询语句，并使用 collection 标签将多的一方的查询结果映射到一的一方的集合属性中。<br>Mybatis中#{}和${}的区别在Mybatis中，#{}和${}都是用来表示参数占位符的，但是它们的作用是不同的。</p><p>#{}用于表示一个占位符，Mybatis会将传入的参数自动进行类型转换，然后将转换后的值安全地插入到SQL语句中。这种方式可以有效地防止SQL注入的风险。<br>${}也用于表示一个占位符，但是它不会对传入的参数进行处理，直接将传入的字符串嵌入到SQL语句中。这种方式存在SQL注入的风险，应该尽量避免使用。<br>因此，建议在Mybatis中使用#{}作为参数占位符，以确保系统的安全性。<br>使用 #{} 时，Mybatis 会将 SQL 语句中的 #{} 替换成一个 ? 占位符，并使用 PreparedStatement 来执行 SQL 语句，这样就可以避免 SQL 注入等安全问题。同时，使用 #{} 还可以自动进行类型转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Mybatis概述&quot;&gt;&lt;a href=&quot;#一、Mybatis概述&quot; class=&quot;headerlink&quot; title=&quot;一、Mybatis概述&quot;&gt;&lt;/a&gt;一、Mybatis概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://starstar-blog.os
      
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://xingxin-99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://xingxin-99.github.io/2023/08/25/%E6%B5%8B%E8%AF%95/"/>
    <id>https://xingxin-99.github.io/2023/08/25/测试/</id>
    <published>2023-08-25T05:52:19.000Z</published>
    <updated>2023-08-25T07:15:16.994Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="测试" scheme="https://xingxin-99.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="https://xingxin-99.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>项目</title>
    <link href="https://xingxin-99.github.io/2023/08/25/%E9%A1%B9%E7%9B%AE/"/>
    <id>https://xingxin-99.github.io/2023/08/25/项目/</id>
    <published>2023-08-25T05:51:45.000Z</published>
    <updated>2023-08-25T07:15:12.645Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="项目" scheme="https://xingxin-99.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="https://xingxin-99.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://xingxin-99.github.io/2023/08/25/MySQL/"/>
    <id>https://xingxin-99.github.io/2023/08/25/MySQL/</id>
    <published>2023-08-25T05:50:48.000Z</published>
    <updated>2023-08-25T07:15:46.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL" scheme="https://xingxin-99.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://xingxin-99.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://xingxin-99.github.io/2023/08/25/Redis/"/>
    <id>https://xingxin-99.github.io/2023/08/25/Redis/</id>
    <published>2023-08-25T05:50:30.000Z</published>
    <updated>2023-08-25T07:22:28.702Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="https://xingxin-99.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://xingxin-99.github.io/2023/08/25/Spring/"/>
    <id>https://xingxin-99.github.io/2023/08/25/Spring/</id>
    <published>2023-08-25T05:49:03.000Z</published>
    <updated>2023-08-25T07:15:18.553Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Spring" scheme="https://xingxin-99.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://xingxin-99.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java</title>
    <link href="https://xingxin-99.github.io/2023/06/24/Java/"/>
    <id>https://xingxin-99.github.io/2023/06/24/Java/</id>
    <published>2023-06-24T14:06:19.000Z</published>
    <updated>2023-08-25T07:19:09.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://xingxin-99.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://xingxin-99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis双写一致性</title>
    <link href="https://xingxin-99.github.io/2023/05/24/Redis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://xingxin-99.github.io/2023/05/24/Redis双写一致性/</id>
    <published>2023-05-24T12:24:16.000Z</published>
    <updated>2023-08-25T07:15:20.198Z</updated>
    
    <content type="html"><![CDATA[<p>双写一致性是为了保证数据库和缓存中的数据最终一致。</p><blockquote><p>删除缓存还是更新缓存？</p></blockquote><ol><li>写多读少场景下浪费性能<br>如果采用更新缓存方式的话，那么每对数据库更新一次，就会更新一次缓存。在写多读少的场景下，如果进行了多次更新，但没有一次读取，那中间更新多次缓存的这个过程是没必要的且浪费性能的，因为我们希望读缓存时读的是相对最新的数据。因此目前大多采用类似于懒加载的这种模式，删除缓存后，不使用时不读缓存，只有使用时再去数据库中读取最新的数据。</li><li>脏数据问题<br>线程1和线程2都要对数据库中的A数据进行写操作。线程1先执行，在写入数据库要更新缓存之前，线程2来对A进行更新并写入缓存，然后线程1再写入缓存。这导致缓存中是A更新后的数据而不是期望的B更新后的数据，导致最后缓存中出现了脏数据。<blockquote><p>先更新数据库还是先删除缓存？</p></blockquote></li></ol><blockquote><p>使用延时双删，为什么要删除两次？为什么第一次要删除？为什么要进行延时？</p></blockquote><p>延时的目的：</p><ol><li>线程B读取数据库，在还未更新缓存时，线程A更新数据库，删除缓存。线程B把读到的数据写入到缓存中，写入的是脏数据。进行延时，等到线程B将脏数据写入到缓存后在进行删除，降低了出现数据不一致性的可能。</li><li>主从同步，需要等待从库等待数据更新后再删除缓存，否则读取的还是从库中未更新的数据。<blockquote><p>如何判断Reidis中的key删除失败？</p></blockquote></li></ol><ul><li>Redis的DEL命令用于删除已存在的键，返回值是删除键的数量</li><li><p>redisTemplate.delete(key)，如果删除失败，返回false</p><blockquote><p>如果延时双删，最后的删失败了怎么办？</p></blockquote></li><li><p>失败重试机制</p><ul><li>同步重试</li><li>异步重试<ul><li>使用消息队列</li></ul></li></ul></li><li>订阅binlog日志</li></ul><p>使用canal组件订阅binlog日志，当发现binlog中有更新数据的日志时，删除相应的缓存。</p><ul><li>定时任务<br>将需要重试的数据写入到重试表中，重试表中有重试次数及数据状态，定时任务每隔一定时间读取重试表中的数据进行重试，如果成功，则将该数据删除，如果不成功则重试次数+1，如果重试次数达到指定值还未更新成功，则重试表中将该记录更新为失败状态。同时考虑是不是由于Redis宕机而导致了更新一直失败，考虑使用Redis集群来提高Redis服务的高可用性。<blockquote><p>如何保证缓存与数据库的强一致性？</p></blockquote></li></ul><p>如果要保证Redis与数据库的强一致性，可以靠考虑使用Redis的互斥锁实现。当要更新数据时，对要更新的key加上互斥锁，同时开启另一个线程对数据库执行写操作。当写操作执行完毕后释放锁。</p><blockquote><p>如何不要求强一致性，可以怎么做？</p></blockquote><ol><li>延时双删</li><li>Canal组件</li></ol>]]></content>
    
    <summary type="html">
    
      Redis和数据库中的数据如何保持一致？
    
    </summary>
    
      <category term="Redis" scheme="https://xingxin-99.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://xingxin-99.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Typora+PicGo+阿里云OSS上传图片</title>
    <link href="https://xingxin-99.github.io/2022/05/25/1/"/>
    <id>https://xingxin-99.github.io/2022/05/25/1/</id>
    <published>2022-05-25T12:24:16.000Z</published>
    <updated>2023-08-25T07:19:07.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h3><ol><li><p>登陆进阿里云OSS<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824132825596.png" alt="image-20230824132825596"></p></li><li><p>创建OSS Bucket<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824133158324.png" alt="image-20230824133158324"></p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824133521869.png" alt="image-20230824133521869"><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824133559834.png" alt></p></li><li><p>获取AccessKey<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824133831946.png" alt="image-20230824133831946"></p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824134040069.png" alt="image-20230824134040069"></p><p>保存AccessKey ID与Secret，后面PicGo图床设置会使用到</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824134139206.png" alt="image-20230824134139206"></p></li></ol><h3 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h3><ol><li>下载PicGo：<br><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">Releases · Molunerfinn/PicGo (github.com)</a></li><li>选择显示图床<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824130630861.png" alt="image-20230824130630861"></li><li>图床设置<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824130854740.png" alt="image-20230824130854740"></li><li>验证图片是否能够上传成功<br><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824131104158.png" alt="image-20230824131104158"></li></ol><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p><strong>Typora上传图片设置：文件-&gt;偏好设置-&gt;图像</strong></p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824131927896.png" alt="image-20230824131927896"></p>]]></content>
    
    <summary type="html">
    
      Typora+PicGo+阿里云OSS上传图片
    
    </summary>
    
      <category term="技术" scheme="https://xingxin-99.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://xingxin-99.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>主题配置</title>
    <link href="https://xingxin-99.github.io/2022/04/25/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>https://xingxin-99.github.io/2022/04/25/主题配置/</id>
    <published>2022-04-25T02:37:16.000Z</published>
    <updated>2023-08-25T07:15:09.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改对话"><a href="#修改对话" class="headerlink" title="修改对话"></a>修改对话</h2><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230825104420164.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;修改对话&quot;&gt;&lt;a href=&quot;#修改对话&quot; class=&quot;headerlink&quot; title=&quot;修改对话&quot;&gt;&lt;/a&gt;修改对话&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://starstar-blog.oss-cn-chengdu.aliyuncs.com/im
      
    
    </summary>
    
      <category term="技术" scheme="https://xingxin-99.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建博客时遇到的问题</title>
    <link href="https://xingxin-99.github.io/2022/03/24/%E6%90%AD%E5%BB%BABlog%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://xingxin-99.github.io/2022/03/24/搭建Blog时遇到的问题/</id>
    <published>2022-03-24T12:24:16.000Z</published>
    <updated>2023-08-25T07:15:14.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题：执行hexo d后报错ssh: connect to host github.com port 22: Connection refused，文件不能部署到Github中</p></blockquote><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824140639251.png" alt="image-20230824140639251"></p><p><strong>解决：换一个端口号</strong></p><ol><li><p>进入.ssh目录，编辑配置文件config</p><pre><code class="shell">cd ~/.sshvim config</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824141033199.png" alt="image-20230824141033199"></p></li><li><p>编辑文件内容</p><pre><code>Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gitlab.comHostname altssh.gitlab.comUser gitPort 443PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824141349564.png" alt="image-20230824141349564"></p></li><li><p>保存退出，检查是否成功</p><pre><code>ssh -T git@github.com</code></pre><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824142340533.png" alt="image-20230824142340533"></p></li><li><p>验证hexo d能否成功部署资源到Github，结果成功</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824142027146.png" alt="image-20230824142027146"></p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230824141848200.png" alt="image-20230824141848200"></p></li></ol><p>参考：<a href="https://blog.csdn.net/weixin_45637036/article/details/106560217" target="_blank" rel="noopener">Git问题</a></p><blockquote><p>在分类下添加标签，没有显示创建出分类下的页面</p></blockquote><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230825140212.png" alt="QQ图片20230825140212"></p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/QQ%E5%9B%BE%E7%89%8720230825140218.png" alt="QQ图片20230825140218"></p><p>解决：</p><p>先生成md文件，在md里添加分类，它会根据这个来生成html页面</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230825140708123.png" alt="image-20230825140708123"></p><p>创建成功后，再添加至配置文件中</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230825140759883.png" alt="image-20230825140759883"></p><p>hexo g 生成页面会发现页面已经成功生成</p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230825140932659.png" alt="image-20230825140932659"></p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230825141238221.png" alt="image-20230825141238221"></p><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230825141328422.png" alt="image-20230825141328422"></p><blockquote><p>如何修改新的分类下的背景图片？</p></blockquote><p><img src="https://starstar-blog.oss-cn-chengdu.aliyuncs.com/image-20230825142155668.png" alt="image-20230825142155668"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;问题：执行hexo d后报错ssh: connect to host github.com port 22: Connection refused，文件不能部署到Github中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="技术" scheme="https://xingxin-99.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
